---
description: use with all git operations and cleanup
globs: 
alwaysApply: false
---
# Git and Cleanup Rules

## Logical Commit Organization

### **MANDATORY**: Split Changes into Logical Commits
When making multiple changes, **ALWAYS** organize them into separate, logical commits that can be understood and reviewed independently. Each commit should represent a single, cohesive change.

#### Logical Commit Categories
1. **Bug Fixes** (`fix:`): Address specific issues or incorrect behavior
2. **Features** (`feat:`): Add new functionality or capabilities
3. **Tests** (`test:`): Add, modify, or enhance test coverage
4. **Refactoring** (`refactor:`): Restructure code without changing behavior
5. **Documentation** (`docs:`): Update documentation, specs, or comments
6. **Cleanup** (`cleanup:`): Remove unused code, files, or dependencies

#### Commit Organization Principles
- **Atomic Changes**: Each commit should be complete and self-contained
- **Single Responsibility**: One logical change per commit
- **Reviewable Size**: Commits should be digestible for code review
- **Dependency Order**: Commit dependencies in logical sequence (tests after code, cleanup after refactoring)
- **Reversible**: Each commit should be safely revertible without breaking the system

### **MANDATORY**: Commit Size Guidelines

#### **Avoid Overly Granular Commits**
- ❌ **Too Small**: Single file changes that are part of a larger feature
- ❌ **Too Small**: Individual test files when they're all testing the same feature
- ❌ **Too Small**: Documentation updates that could be grouped with related code changes
- ❌ **Too Small**: Minor fixes that could be combined with related changes

#### **Optimal Commit Sizes**

**✅ Feature Commits**: Complete logical features
```bash
# GOOD: Complete feature with CLI, core logic, and basic tests
git commit -m "feat: implement annual report generation with CLI, engine, and templates"

# BAD: Too granular - split across multiple commits
git commit -m "feat: add annual report CLI"
git commit -m "feat: add annual report engine" 
git commit -m "feat: add annual report templates"
```

**✅ Test Commits**: All tests for a feature together
```bash
# GOOD: Comprehensive test suite for a feature
git commit -m "test: add comprehensive test suite for annual aggregation including CLI, engine, and integration"

# BAD: Too granular - individual test files
git commit -m "test: add CLI tests for annual aggregation"
git commit -m "test: add engine tests for annual aggregation"
git commit -m "test: add integration tests for annual aggregation"
```

**✅ Refactor Commits**: Complete refactoring of a module or pattern
```bash
# GOOD: Complete refactoring with all related changes
git commit -m "refactor: unify all file I/O operations with atomic writes and error handling"

# BAD: Too granular - individual module refactoring
git commit -m "refactor: update aggregate save to use unified utilities"
git commit -m "refactor: update enrich save to use unified utilities"
git commit -m "refactor: update report save to use unified utilities"
```

**✅ Documentation Commits**: Group related docs with their code changes
```bash
# GOOD: Documentation with related code changes
git commit -m "feat: implement brush matching strategy with comprehensive documentation"

# BAD: Separate documentation commits for related code
git commit -m "feat: implement brush matching strategy"
git commit -m "docs: add brush matching documentation"
```

#### **When to Split Commits**

**Split when:**
- **Different logical concerns**: Feature implementation vs bug fixes
- **Different modules**: Unrelated functionality changes
- **Different phases**: Core logic vs CLI vs tests vs documentation
- **Breaking changes**: Changes that could affect other developers

**Combine when:**
- **Same logical unit**: All parts of a single feature
- **Related functionality**: CLI, core logic, and basic tests for same feature
- **Same module**: Multiple related changes within same file/module
- **Dependent changes**: Changes that must be deployed together

#### Examples of Good Commit Organization

**Scenario: Adding new brush matching strategy with tests and documentation**
```bash
# GOOD: Logical grouping by concern
git commit -m "feat: add Zenith brush matching strategy with B-series pattern recognition"
git commit -m "test: add comprehensive test suite for Zenith strategy including unit and integration tests"
git commit -m "docs: update brush matching specification with Zenith strategy details"
```

**Scenario: Fixing bug with multiple affected components**
```bash
# GOOD: Bug fix with comprehensive test coverage
git commit -m "fix: correct Declaration Grooming strategy false positive matching with comprehensive test updates"
```

**Scenario: Refactoring with consistency improvements**
```bash
# GOOD: Complete refactoring with all related changes
git commit -m "refactor: unify delimiter handling and model naming across all brush strategies"
```

**Scenario: Annual report feature implementation**
```bash
# GOOD: Complete feature implementation
git commit -m "feat: implement annual report generation with CLI, engine, templates, and basic validation"
git commit -m "test: add comprehensive test suite for annual report functionality including CLI, engine, and integration"
git commit -m "docs: update report phase specification with annual report details"
```

#### What NOT to Do
- ❌ **Monolithic commits**: `git commit -m "fix various issues and add tests"`
- ❌ **Mixed concerns**: Combining bug fixes with new features in one commit
- ❌ **Incomplete changes**: Committing broken code that requires follow-up commits
- ❌ **Generic messages**: `git commit -m "updates"` or `git commit -m "changes"`
- ❌ **Overly granular**: Single file changes that are part of a larger logical unit
- ❌ **Scattered tests**: Individual test commits when they all test the same feature

### Commit Message Standards

#### Format Requirements
Use conventional commit format with clear, descriptive messages:
```
<type>: <short description>

[optional longer description explaining why the change was made]

[optional footer with breaking changes or issue references]
```

#### Message Quality Guidelines
- **Imperative mood**: "Add feature" not "Added feature" or "Adding feature"
- **Specific descriptions**: Explain WHAT changed and WHY
- **Context for reviewers**: Include enough detail for code review
- **50/72 rule**: First line ≤50 chars, body lines ≤72 chars
- **No periods**: Don't end the subject line with a period

#### Enhanced Commit Type Examples

**Bug Fixes (`fix:`):**
- `fix: prevent Declaration Grooming false positives for Zenith B2 patterns`
- `fix: resolve handle/knot splitting inconsistency with ambiguous delimiters`
- `fix: correct fiber strategy detection when user input conflicts with catalog`

**Features (`feat:`):**
- `feat: implement intelligent handle/knot parsing with content analysis scoring`
- `feat: add support for Chisel & Hound versioned knot patterns (V10-V27)`
- `feat: integrate real-time catalog validation in brush matching strategies`

**Tests (`test:`):**
- `test: add comprehensive integration tests using production YAML catalogs`
- `test: implement model naming consistency validation across all strategies`
- `test: enhance brush matcher tests with delimiter unification scenarios`

**Refactoring (`refactor:`):**
- `refactor: consolidate brush catalog files into unified brushes.yaml structure`
- `refactor: extract common pattern compilation logic into base matcher class`
- `refactor: simplify strategy priority handling with unified interface`

**Documentation (`docs:`):**
- `docs: update brush matching specification with intelligent parsing details`
- `docs: enhance testing patterns to mandate dual unit/integration coverage`
- `docs: document delimiter semantics and content analysis scoring algorithms`

**Cleanup (`cleanup:`):**
- `cleanup: remove deprecated knot_maker field and update all references`
- `cleanup: eliminate unused brush_yaml directory after consolidation`
- `cleanup: remove redundant imports and apply ruff formatting fixes`

## Git Ignore Patterns
- Use `!data/*.yaml` to include all YAML catalogs without listing each file individually
- Exclude temporary files, logs, and generated data
- Keep override files and configuration templates

```gitignore
# Virtual environments
venv/
.venv/
env/

# Python cache
__pycache__/
*.pyc
*.pyo
*.pyd

# Testing and coverage
.pytest_cache/
.coverage
coverage/
htmlcov/

# Data files (but keep YAML catalogs)
data/*
!data/*.yaml

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo

# Logs and temporary files
*.log
.aider*
praw.ini  # API credentials
```

## File Cleanup Guidelines
- Remove redundant files when consolidating data structures
- Update imports when moving or removing modules
- Clean up unused test fixtures and mock data
- Remove deprecated code paths after refactoring

## Refactoring Cleanup Checklist
When removing or consolidating code:

1. **Search for all references** using grep/ripgrep
2. **Update imports** in affected modules
3. **Remove unused test files** and fixtures
4. **Update .gitignore** if file patterns change
5. **Check for broken imports** with `make typecheck`
6. **Run full test suite** to catch integration issues
7. **Update documentation** if APIs change

## Temporary File Management
- Use `tmp_path` fixture in tests for temporary files
- Clean up generated test data in teardown
- Don't commit temporary debugging files
- Use descriptive names for temporary variables (avoid `temp`, `tmp`)

## Code Removal Best Practices
```python
# Before removing a function/class, check usage:
# grep -r "function_name" . --include="*.py"

# When removing fields from data structures:
# 1. Update all tests that reference the field
# 2. Update documentation/specs
# 3. Check for serialization/deserialization code
# 4. Verify no downstream consumers depend on the field

# Example: Removing knot_maker field
# ✓ Remove from strategy return values
# ✓ Remove from test assertions  
# ✓ Update documentation
# ✓ Check for any enrichment code using the field
```

## Dependency Cleanup
- Remove unused imports at the top of files
- Use `ruff --fix` to automatically remove unused imports
- Check for unused dependencies in requirements.txt
- Remove commented-out code blocks

## Data Migration Patterns
When consolidating data files:

```python
# Pattern for migrating from multiple files to single file
def migrate_brush_data():
    """Example: Consolidating brush_yaml/* into brushes.yaml"""
    old_files = [
        "data/brush_yaml/known_brushes.yaml",
        "data/brush_yaml/other_brushes.yaml",
        "data/brush_yaml/dg_brushes.yaml"
    ]
    
    consolidated = {}
    for file_path in old_files:
        if Path(file_path).exists():
            with open(file_path) as f:
                data = yaml.safe_load(f)
                consolidated.update(data)
    
    # Write consolidated file
    with open("data/brushes.yaml", "w") as f:
        yaml.dump(consolidated, f, default_flow_style=False)
```

## Commit Message Patterns
- `feat:` for new features
- `fix:` for bug fixes  
- `refactor:` for code restructuring
- `test:` for test changes
- `docs:` for documentation
- `cleanup:` for removing unused code/files

Examples:
- `cleanup: remove redundant brush_yaml folder and consolidate into brushes.yaml`
- `refactor: remove knot_maker field as redundant with brand`
- `fix: correct handle_maker key naming in brush matcher tests`

## Plan Management and Naming Conventions

### **MANDATORY**: Completed Plan Naming Convention
When moving implementation plans to the `plans/completed/` folder, **ALWAYS** include the completion date in the filename to avoid conflicts and maintain historical tracking.

#### Format: `{plan_name}_{YYYY-MM-DD}.mdc`

**Examples:**
- `refactoring_implementation_plan_2024-12-19.mdc`
- `bug_fix_plan_2024-12-20.mdc`
- `feature_implementation_plan_2024-12-21.mdc`

#### Why This Matters
- **Avoids conflicts**: Multiple plans with the same name can coexist
- **Historical tracking**: Easy to see when plans were completed
- **Better organization**: Clear timeline of project milestones
- **Future reference**: Can track how long different types of work take

#### Process for Completing Plans
1. **Update the plan** with final completion status and summary
2. **Move to completed folder** with date suffix: `plans/completed/{plan_name}_{YYYY-MM-DD}.mdc`
3. **Remove original** from root `plans/` directory
4. **Commit both changes** together with descriptive message

#### Example Workflow
```bash
# 1. Update plan with completion status
# 2. Move with date suffix using git mv (not regular mv)
git mv plans/feature_plan.mdc plans/completed/feature_plan_2024-12-19.mdc

# 3. Remove original (git mv handles this automatically)
# No need for separate rm command when using git mv

# 4. Commit the rename
git commit -m "docs(plan): mark feature plan complete and move to completed folder with date suffix"
```

#### **MANDATORY**: Use `git mv` for Plan Renames
- ✅ **Use**: `git mv plans/plan.mdc plans/completed/plan_YYYY-MM-DD.mdc`
- ❌ **Don't use**: `mv plans/plan.mdc plans/completed/plan_YYYY-MM-DD.mdc`
- **Why**: `git mv` explicitly tells Git this is a rename operation, preserving file history and showing up as "rename" in git log
- **Benefit**: Better semantic tracking and cleaner git history

#### Commit Message Pattern for Plan Completion
- `docs(plan): mark {plan_name} complete and move to completed folder with date suffix`
- `docs(plan): complete {plan_name} implementation and archive with completion date`

#### What NOT to Do
- ❌ **Generic names**: `plan.mdc` or `implementation.mdc`
- ❌ **No date suffix**: `refactoring_plan.mdc` (will conflict with future plans)
- ❌ **Separate commits**: Moving and updating in different commits
- ❌ **Incomplete status**: Moving plans without final completion summary
