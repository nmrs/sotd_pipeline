git
# Git and Cleanup Rules

## **CRITICAL**: File Naming with Dates

### **MANDATORY**: Always Use Actual Current Date
When creating ANY file with a date in the filename, **ALWAYS** run `date +%Y-%m-%d` to get the actual current date. Never use assumed, guessed, or copied dates.

**Examples:**
```bash
# ALWAYS do this first:
CURRENT_DATE=$(date +%Y-%m-%d)
echo $CURRENT_DATE  # Verify the date

# Then use it in filenames:
blade_format_aware_validation_plan_${CURRENT_DATE}.mdc
```

**Common Mistakes:**
- ❌ Using dates from examples: `plan_2025-01-28.mdc` (wrong!)
- ❌ Assuming the date: `plan_2025-07-08.mdc` (might be wrong!)
- ❌ Copying from other files: Using dates from existing files

**Correct Process:**
1. Run `date +%Y-%m-%d` to get actual current date
2. Use that exact date in the filename
3. Double-check the date is correct

## Logical Commit Organization

### **MANDATORY**: Split Changes into Logical Commits
When making multiple changes, **ALWAYS** organize them into separate, logical commits that can be understood and reviewed independently. Each commit should represent a single, cohesive change.

#### Logical Commit Categories
1. **Bug Fixes** (`fix:`): Address specific issues or incorrect behavior
2. **Features** (`feat:`): Add new functionality or capabilities
3. **Tests** (`test:`): Add, modify, or enhance test coverage
4. **Refactoring** (`refactor:`): Restructure code without changing behavior
5. **Documentation** (`docs:`): Update documentation, specs, or comments
6. **Data** (`data:`): Update catalog data, configuration files, or data maintenance
7. **Cleanup** (`cleanup:`): Remove unused code, files, or dependencies

#### Commit Organization Principles
- **Atomic Changes**: Each commit should be complete and self-contained
- **Single Responsibility**: One logical change per commit
- **Reviewable Size**: Commits should be digestible for code review
- **Dependency Order**: Commit dependencies in logical sequence (tests after code, cleanup after refactoring)
- **Reversible**: Each commit should be safely revertible without breaking the system

### **MANDATORY**: Commit Size Guidelines

#### **Avoid Overly Granular Commits**
- ❌ **Too Small**: Single file changes that are part of a larger feature
- ❌ **Too Small**: Individual test files when they're all testing the same feature
- ❌ **Too Small**: Documentation updates that could be grouped with related code changes
- ❌ **Too Small**: Minor fixes that could be combined with related changes

#### **Optimal Commit Sizes**

**✅ Feature Commits**: Complete logical features
```bash
# GOOD: Complete feature with CLI, core logic, and basic tests
git commit -m "feat: implement annual report generation with CLI, engine, and templates"

# BAD: Too granular - split across multiple commits
git commit -m "feat: add annual report CLI"
git commit -m "feat: add annual report engine" 
git commit -m "feat: add annual report templates"
```

**✅ Test Commits**: All tests for a feature together
```bash
# GOOD: Comprehensive test suite for a feature
git commit -m "test: add comprehensive test suite for annual aggregation including CLI, engine, and integration"

# BAD: Too granular - individual test files
git commit -m "test: add CLI tests for annual aggregation"
git commit -m "test: add engine tests for annual aggregation"
git commit -m "test: add integration tests for annual aggregation"
```

**✅ Refactor Commits**: Complete refactoring of a module or pattern
```bash
# GOOD: Complete refactoring with all related changes
git commit -m "refactor: unify all file I/O operations with atomic writes and error handling"

# BAD: Too granular - individual module refactoring
git commit -m "refactor: update aggregate save to use unified utilities"
git commit -m "refactor: update enrich save to use unified utilities"
git commit -m "refactor: update report save to use unified utilities"
```

**✅ Documentation Commits**: Group related docs with their code changes
```bash
# GOOD: Documentation with related code changes
git commit -m "feat: implement brush matching strategy with comprehensive documentation"

# BAD: Separate documentation commits for related code
git commit -m "feat: implement brush matching strategy"
git commit -m "docs: add brush matching documentation"
```

#### **When to Split Commits**

**Split when:**
- **Different logical concerns**: Feature implementation vs bug fixes
- **Different modules**: Unrelated functionality changes
- **Different phases**: Core logic vs CLI vs tests vs documentation
- **Breaking changes**: Changes that could affect other developers

**Combine when:**
- **Same logical unit**: All parts of a single feature
- **Related functionality**: CLI, core logic, and basic tests for same feature
- **Same module**: Multiple related changes within same file/module
- **Dependent changes**: Changes that must be deployed together

#### Examples of Good Commit Organization

**Scenario: Adding new brush matching strategy with tests and documentation**
```bash
# GOOD: Logical grouping by concern
git commit -m "feat: add Zenith brush matching strategy with B-series pattern recognition"
git commit -m "test: add comprehensive test suite for Zenith strategy including unit and integration tests"
git commit -m "docs: update brush matching specification with Zenith strategy details"
```

**Scenario: Fixing bug with multiple affected components**
```bash
# GOOD: Bug fix with comprehensive test coverage
git commit -m "fix: correct Declaration Grooming strategy false positive matching with comprehensive test updates"
```

**Scenario: Refactoring with consistency improvements**
```bash
# GOOD: Complete refactoring with all related changes
git commit -m "refactor: unify delimiter handling and model naming across all brush strategies"
```

**Scenario: Annual report feature implementation**
```bash
# GOOD: Complete feature implementation
git commit -m "feat: implement annual report generation with CLI, engine, templates, and basic validation"
git commit -m "test: add comprehensive test suite for annual report functionality including CLI, engine, and integration"
git commit -m "docs: update report phase specification with annual report details"
```

#### What NOT to Do
- ❌ **Monolithic commits**: `git commit -m "fix various issues and add tests"`
- ❌ **Mixed concerns**: Combining bug fixes with new features in one commit
- ❌ **Incomplete changes**: Committing broken code that requires follow-up commits
- ❌ **Generic messages**: `git commit -m "updates"` or `git commit -m "changes"`
- ❌ **Overly granular**: Single file changes that are part of a larger logical unit
- ❌ **Scattered tests**: Individual test commits when they all test the same feature

### Commit Message Standards

#### Format Requirements
Use conventional commit format with clear, descriptive messages:
```
<type>: <short description>

[optional longer description explaining why the change was made]

[optional footer with breaking changes or issue references]
```

#### Message Quality Guidelines
- **Imperative mood**: "Add feature" not "Added feature" or "Adding feature"
- **Specific descriptions**: Explain WHAT changed and WHY
- **Context for reviewers**: Include enough detail for code review
- **50/72 rule**: First line ≤50 chars, body lines ≤72 chars
- **No periods**: Don't end the subject line with a period

#### Enhanced Commit Type Examples

**Bug Fixes (`fix:`):**
- `fix: prevent Declaration Grooming false positives for Zenith B2 patterns`
- `fix: resolve handle/knot splitting inconsistency with ambiguous delimiters`
- `fix: correct fiber strategy detection when user input conflicts with catalog`

**Features (`feat:`):**
- `feat: implement intelligent handle/knot parsing with content analysis scoring`
- `feat: add support for Chisel & Hound versioned knot patterns (V10-V27)`
- `feat: integrate real-time catalog validation in brush matching strategies`

**Tests (`test:`):**
- `test: add comprehensive integration tests using production YAML catalogs`
- `test: implement model naming consistency validation across all strategies`
- `test: enhance brush matcher tests with delimiter unification scenarios`

**Refactoring (`refactor:`):**
- `refactor: consolidate brush catalog files into unified brushes.yaml structure`
- `refactor: extract common pattern compilation logic into base matcher class`
- `refactor: simplify strategy priority handling with unified interface`

**Documentation (`docs:`):**
- `docs: update brush matching specification with intelligent parsing details`
- `docs: enhance testing patterns to mandate dual unit/integration coverage`
- `docs: document delimiter semantics and content analysis scoring algorithms`

**Data (`data:`):**
- `data: add new blade catalog entries for AMC De-Luxe Thin and Gillette Stainless`
- `data: update intentionally unmatched items with garbage and non-razor entries`
- `data: add new brush patterns for Zenith B-series handle recognition`
- `data: update correct_matches.yaml with manually verified product matches`

**Cleanup (`cleanup:`):**
- `cleanup: remove deprecated knot_maker field and update all references`
- `cleanup: eliminate unused brush_yaml directory after consolidation`
- `cleanup: remove redundant imports and apply ruff formatting fixes`

**⚠️ IMPORTANT: Cleanup vs Behavior Changes**

**Use `cleanup:` for:**
- Removing unused/dead code that's not called anywhere
- Deleting unused files, imports, or dependencies
- Removing deprecated fields or methods that are no longer referenced
- Applying formatting fixes (ruff, black)
- Removing unused configuration or environment variables
- Cleaning up whitespace, comments, or documentation typos
- Removing unused test fixtures or mock data

**Use `fix:` for bug fixes:**
- Resolving actual bugs or incorrect behavior
- Fixing broken functionality
- Correcting errors in logic or implementation
- Resolving issues that cause failures or incorrect results

**Use `feat:` for new features/enhancements:**
- Adding new functionality
- Enhancing existing features
- Adding new capabilities or options

**Use `refactor:` for behavior changes that aren't bugs:**
- Restructuring code that changes behavior
- Improving implementation without fixing bugs
- Changing how features work for better design

**Use `perf:` for performance changes:**
- Optimizing performance that changes behavior
- Improving speed, memory usage, or efficiency

**Examples:**
```bash
# ✅ GOOD cleanup: Removing unused code
cleanup: remove unused imports and dead code after refactoring

# ✅ GOOD fix: Fixing actual bug
fix: resolve web UI vs CLI discrepancy by removing stale cache

# ✅ GOOD refactor: Changing behavior for better design
refactor: remove client-side caching to ensure fresh API calls

# ✅ GOOD feat: Adding new capability
feat: add dynamic fallback formats for better blade matching

# ❌ BAD: Calling behavior change "cleanup"
cleanup: remove client-side caching (this changes behavior!)

# ❌ BAD: Calling dead code removal "fix"
fix: remove unused imports (this doesn't fix anything!)

# ❌ BAD: Calling bug fix "refactor"
refactor: fix broken blade matching (this is a bug fix!)
```

## Comprehensive Rollback Procedures

### **MANDATORY**: Complete Work Rollback
When asked to undo work or rollback progress, **ALWAYS** perform a comprehensive analysis to identify and remove ALL related changes, not just the primary feature.

#### Rollback Analysis Process
1. **Review git history** to identify all commits related to the work being undone
2. **Search for related changes** across the entire codebase that support or depend on the feature
3. **Identify supporting infrastructure** (tests, documentation, configuration changes)
4. **Check for integration points** where the feature was integrated into existing systems
5. **Remove all related changes** in a single, comprehensive rollback

#### **MANDATORY**: Git History Review
Before performing any rollback, **ALWAYS** examine recent git history to identify all related commits:

```bash
# Review recent commits to identify all related changes
git log --oneline -20  # Review last 20 commits
git log --grep="feature_name" --oneline  # Search for specific feature
git log --grep="analysis_tool" --oneline  # Example: search for analysis tool commits
```

#### **MANDATORY**: Cross-Module Impact Analysis
When rolling back a feature, **ALWAYS** check for changes in related modules that support the feature:

**Example Scenarios:**
- **Analysis Tool Rollback**: If removing an analysis tool, also check for:
  - Changes to matchers (razor_matcher.py, brush_matcher.py, etc.)
  - CLI integration changes
  - Test files for the tool
  - Documentation updates
  - Configuration changes
  - Import statements added to support the tool

- **Feature Rollback**: If removing a feature, also check for:
  - Supporting infrastructure changes
  - Database schema changes
  - API endpoint modifications
  - UI/CLI changes
  - Test coverage additions
  - Documentation updates

#### **MANDATORY**: Comprehensive Removal Checklist
When rolling back work, ensure ALL of the following are addressed:

**Code Changes:**
- [ ] Primary feature files removed
- [ ] Supporting module changes reverted
- [ ] Integration points removed
- [ ] Import statements cleaned up
- [ ] Configuration changes reverted

**Test Changes:**
- [ ] Test files for the feature removed
- [ ] Test fixtures and mock data cleaned up
- [ ] Integration tests updated
- [ ] Test configuration changes reverted

**Documentation Changes:**
- [ ] Feature documentation removed
- [ ] API documentation updated
- [ ] README files cleaned up
- [ ] Specification documents reverted

**Infrastructure Changes:**
- [ ] Configuration files reverted
- [ ] Build system changes removed
- [ ] Dependency changes reverted
- [ ] Environment setup changes cleaned up

#### **MANDATORY**: Single Rollback Commit
All rollback changes should be committed together in a single, comprehensive commit:

```bash
# GOOD: Comprehensive rollback with clear description
git commit -m "rollback: remove analysis tool and all supporting changes

- Remove analysis tool implementation
- Revert razor matcher changes that supported the tool
- Remove test files for the analysis tool
- Clean up CLI integration changes
- Remove documentation for the feature
- Revert configuration changes"

# BAD: Partial rollback that leaves related changes
git commit -m "rollback: remove analysis tool"
# Missing: razor matcher changes, tests, documentation, etc.
```

#### **MANDATORY**: Validation After Rollback
After completing a rollback, **ALWAYS** validate that the system is in a clean state:

```bash
# Run quality checks to ensure no broken references
make format lint typecheck test

# Check for any remaining references to removed features
grep -r "removed_feature_name" . --include="*.py" --exclude-dir=.git

# Verify imports are clean
grep -r "from.*removed_module" . --include="*.py" --exclude-dir=.git
```

#### Rollback Examples

**Example 1: Analysis Tool Rollback**
```bash
# Scenario: Remove analysis tool that required razor matcher changes
# 1. Review git history for all related commits
git log --grep="analysis" --oneline

# 2. Identify all related changes:
# - sotd/match/tools/analysis_tool.py (primary feature)
# - sotd/match/razor_matcher.py (supporting changes)
# - tests/match/tools/test_analysis_tool.py (tests)
# - docs/analysis_tool_spec.md (documentation)

# 3. Remove all changes in single commit
git rm sotd/match/tools/analysis_tool.py
git checkout HEAD~1 -- sotd/match/razor_matcher.py  # Revert supporting changes
git rm tests/match/tools/test_analysis_tool.py
git rm docs/analysis_tool_spec.md

# 4. Commit comprehensive rollback
git commit -m "rollback: remove analysis tool and all supporting infrastructure

- Remove analysis tool implementation and tests
- Revert razor matcher changes that supported the tool
- Remove documentation and specifications
- Clean up all integration points"
```

**Example 2: Feature Rollback with Multiple Dependencies**
```bash
# Scenario: Remove feature that touched multiple modules
# 1. Review git history for feature-related commits
git log --grep="feature_name" --oneline

# 2. Identify all related changes across modules
# - Primary feature files
# - Supporting infrastructure changes
# - Test coverage additions
# - Documentation updates
# - Configuration changes

# 3. Comprehensive rollback
git checkout HEAD~3 -- module1.py  # Revert to state before feature
git checkout HEAD~2 -- module2.py  # Revert supporting changes
git rm -r feature_directory/       # Remove feature files
git rm tests/test_feature.py       # Remove tests
git rm docs/feature_spec.md        # Remove documentation

# 4. Commit with detailed description
git commit -m "rollback: remove feature_name and all related changes

- Remove primary feature implementation
- Revert supporting changes in module1.py and module2.py
- Remove test coverage for the feature
- Clean up documentation and specifications
- Revert configuration changes"
```

#### What NOT to Do During Rollback
- ❌ **Partial rollback**: Removing only the primary feature without supporting changes
- ❌ **Multiple commits**: Splitting rollback across multiple commits
- ❌ **Incomplete cleanup**: Leaving references to removed features
- ❌ **No validation**: Not running tests after rollback
- ❌ **Generic messages**: `git commit -m "rollback changes"`
- ❌ **Missing dependencies**: Not checking for changes in related modules

#### **MANDATORY**: Rollback Documentation
When performing a rollback, **ALWAYS** document the reason and scope:

```bash
# Include detailed description in commit message
git commit -m "rollback: remove feature_name due to [reason]

- Remove primary feature implementation
- Revert supporting changes in [list modules]
- Remove test coverage and documentation
- Clean up all integration points

Reason: [explain why rollback was necessary]
Impact: [describe what was affected]"
```

## Test Execution Optimization

### **MANDATORY**: Use Fast Test Modes by Default
When running tests during development, **ALWAYS** use the fastest available test mode unless debugging specific failures.

#### Test Execution Priority
1. **`make test-fast`** - Fast parallel execution (~6s) - **PREFERRED for development**
2. **`make test-parallel`** - Maximum parallel execution (~6s) - **ALTERNATIVE for development**
3. **`make test`** - Normal sequential execution (~13s) - **ONLY for debugging failures**

#### When to Use Each Mode

**✅ Use `make test-fast` for:**
- Regular development feedback
- Pre-commit validation
- Quick iteration cycles
- Most development scenarios

**✅ Use `make test-parallel` for:**
- When `make test-fast` is not available
- Maximum speed on multi-core machines
- CI/CD environments

**✅ Use `make test` for:**
- Debugging specific test failures
- When you need detailed sequential output
- Investigating test behavior step-by-step
- **ONLY when fast modes show failures**

#### Quality Check Commands
```bash
# PREFERRED: Fast quality checks
make format lint typecheck test-fast

# ALTERNATIVE: Maximum speed
make format lint typecheck test-parallel

# FALLBACK: Normal mode (only for debugging)
make format lint typecheck test
```

#### Development Workflow
```bash
# 1. Make changes
# 2. Run fast tests for quick feedback
make test-fast

# 3. If tests pass, run full quality checks
make format lint typecheck test-fast

# 4. If tests fail, debug with normal mode
make test  # Only when debugging specific failures

# 5. Commit when all checks pass
git commit -m "feat: implement new feature with comprehensive testing"
```

#### Performance Benefits
- **Fast mode:** ~6 seconds vs ~13 seconds (54% faster)
- **Parallel mode:** ~6 seconds vs ~13 seconds (54% faster)
- **Development efficiency:** Faster feedback loops
- **CI/CD speed:** Reduced pipeline times

#### Exception: Debugging Failures
When tests fail in fast/parallel modes, switch to normal mode for detailed debugging:

```bash
# If fast mode shows failures
make test-fast  # Shows failures
make test       # Run normal mode for detailed output

# Debug the specific failing tests
# Fix the issues
# Return to fast mode for validation
make test-fast  # Verify fixes work
```

## Plan Management and Naming Conventions

### **MANDATORY**: Completed Plan Naming Convention
When moving implementation plans to the `plans/completed/` folder, **ALWAYS** include the completion date in the filename to avoid conflicts and maintain historical tracking.

#### Format: `{plan_name}_{YYYY-MM-DD}.mdc`

**Examples:**
- `refactoring_implementation_plan_2024-12-19.mdc`
- `bug_fix_plan_2024-12-20.mdc`
- `feature_implementation_plan_2024-12-21.mdc`

#### **MANDATORY**: Use Actual Current Date
**ALWAYS** use the actual current date when creating plan filenames. **NEVER** assume or guess the date.

**Correct Process:**
1. **Get actual current date**: Use `date +%Y-%m-%d` command
2. **Use exact date**: Include the actual date in the filename
3. **Verify accuracy**: Double-check the date is correct

**CRITICAL**: When creating ANY file with a date in the filename, **ALWAYS** run `date +%Y-%m-%d` to get the actual current date. Never use dates from examples or assume what the date should be.

**Examples:**
```bash
# GOOD: Get actual current date
date +%Y-%m-%d  # Returns actual current date like 2025-07-09

# GOOD: Use actual date in filename
ml_matching_enhancement_plan_2025-07-09.mdc

# BAD: Assume or guess date
ml_matching_enhancement_plan_2025-01-27.mdc  # Wrong date!

# BAD: Use date from examples
blade_format_aware_validation_plan_2025-01-28.mdc  # Wrong date!
```

**Common Mistakes to Avoid:**
- ❌ Using dates from examples or documentation
- ❌ Assuming the date based on context
- ❌ Using yesterday's or tomorrow's date
- ❌ Copying dates from other files
- ❌ Using placeholder dates like "2025-01-01"

#### Why This Matters
- **Avoids conflicts**: Multiple plans with the same name can coexist
- **Historical tracking**: Easy to see when plans were completed
- **Better organization**: Clear timeline of project milestones
- **Future reference**: Can track how long different types of work take
- **Accuracy**: Prevents confusion from incorrect dates

### **MANDATORY**: Unified Plan Completion Policy
**ALL completed plans** (regardless of their original location) must be moved to `plans/completed/` with appropriate subfolder organization.

#### Plan Organization Structure
```
plans/
├── completed/
│   ├── bugs/                    # Completed bug fix plans
│   │   ├── match_phase_output_bug_plan_2025-01-27.mdc
│   │   └── ...
│   ├── data-recovery/           # Completed data recovery plans
│   │   ├── missing_months_recovery_plan_2025-06-20.mdc
│   │   └── ...
│   ├── features/                # Completed feature implementation plans
│   │   ├── annual_report_plan_2025-06-20.mdc
│   │   └── ...
│   ├── refactoring/             # Completed refactoring plans
│   │   ├── refactoring_implementation_plan_2024-12-19.mdc
│   │   └── ...
│   └── ...                      # Other categories as needed
├── bugs/                        # Active bug fix plans
├── data-recovery/               # Active data recovery plans
├── features/                    # Active feature plans
└── ...                          # Other active plan categories
```

#### Benefits of Unified Policy
- **Single source of truth**: All completed work in one location
- **Easy discovery**: Can quickly find all completed plans regardless of origin
- **Consistent organization**: Same structure for all completed work
- **Historical tracking**: Clear timeline of all project milestones
- **Better archival**: Proper separation of active vs completed work

#### Process for Completing Plans
1. **Update the plan** with final completion status and summary
2. **Create subfolder** in `plans/completed/` if it doesn't exist (e.g., `plans/completed/bugs/`)
3. **Move to completed folder** with date suffix: `plans/completed/{category}/{plan_name}_{YYYY-MM-DD}.mdc`
4. **Remove original** from source location
5. **Commit both changes** together with descriptive message

#### Example Workflow
```bash
# 1. Update plan with completion status
# 2. Create subfolder if needed
mkdir -p plans/completed/bugs

# 3. Get actual current date
CURRENT_DATE=$(date +%Y-%m-%d)

# 4. Move with actual date suffix using git mv
git mv plans/bugs/match_phase_output_bug_plan.mdc plans/completed/bugs/match_phase_output_bug_plan_${CURRENT_DATE}.mdc

# 5. Remove original (git mv handles this automatically)
# No need for separate rm command when using git mv

# 6. Commit the rename
git commit -m "docs(plan): mark match phase output bug plan complete and move to completed/bugs with date suffix"
```

#### **MANDATORY**: Use `git mv` for Plan Renames
- ✅ **Use**: `git mv plans/bugs/plan.mdc plans/completed/bugs/plan_YYYY-MM-DD.mdc`
- ❌ **Don't use**: `mv plans/bugs/plan.mdc plans/completed/bugs/plan_YYYY-MM-DD.mdc`
- **Why**: `git mv` explicitly tells Git this is a rename operation, preserving file history and showing up as "rename" in git log
- **Benefit**: Better semantic tracking and cleaner git history

#### Commit Message Pattern for Plan Completion
- `docs(plan): mark {plan_name} complete and move to completed/{category} with date suffix`
- `docs(plan): complete {plan_name} implementation and archive in completed/{category}`

#### Subfolder Categories
- **`bugs/`**: Bug fix plans and investigations
- **`data-recovery/`**: Data recovery and missing data plans
- **`features/`**: Feature implementation plans
- **`refactoring/`**: Code refactoring and restructuring plans
- **`testing/`**: Test implementation and improvement plans
- **`documentation/`**: Documentation improvement plans
- **`performance/`**: Performance optimization plans
- **`infrastructure/`**: Infrastructure and tooling plans

#### What NOT to Do
- ❌ **Generic names**: `plan.mdc` or `implementation.mdc`
- ❌ **No date suffix**: `match_phase_bug.mdc` (will conflict with future plans)
- ❌ **Separate commits**: Moving and updating in different commits
- ❌ **Incomplete status**: Moving plans without final completion summary
- ❌ **Mixed categories**: Putting plans in wrong subfolders
- ❌ **Leaving originals**: Not removing the original plan file after moving
- ❌ **Assumed dates**: Using guessed or assumed dates instead of actual current date

#### Migration from Old Structure
When migrating existing completed plans to the new structure:
1. **Identify completed plans** in subdirectories
2. **Create appropriate subfolders** in `plans/completed/`
3. **Move with git mv** using proper naming convention
4. **Update any references** to the old plan locations
5. **Commit all changes** together with descriptive message

## Git Ignore Patterns
- Use `!data/*.yaml` to include all YAML catalogs without listing each file individually
- Exclude temporary files, logs, and generated data
- Keep override files and configuration templates

```gitignore
# Virtual environments
venv/
.venv/
env/

# Python cache
__pycache__/
*.pyc
*.pyo
*.pyd

# Testing and coverage
.pytest_cache/
.coverage
coverage/
htmlcov/
```

## File Cleanup Guidelines

### **MANDATORY**: Use `git rm` for ALL Deletions
When removing files from the repository, **ALWAYS** use `git rm` instead of `rm` to ensure proper Git tracking and history preservation. This applies to ALL file deletions, not just Git operations.

#### **MANDATORY**: File Deletion Commands
- ✅ **Use**: `git rm filename` - Removes file and stages deletion
- ✅ **Use**: `git rm -r directory/` - Removes directory recursively
- ❌ **Don't use**: `rm filename` - Removes file but doesn't update Git
- ❌ **Don't use**: `rm -rf directory/` - Removes directory but doesn't update Git

#### **MANDATORY**: Git Rm Benefits
- **Proper tracking**: Git knows the file was intentionally removed
- **History preservation**: File history is maintained in Git
- **Staging**: Deletion is automatically staged for commit
- **Clean commits**: No need for separate `git add` after deletion
- **Revert capability**: Can easily revert file deletion if needed
- **No orphaned files**: Prevents files from remaining in Git history when deleted from filesystem
- **Consistent state**: Ensures Git repository state matches filesystem state

#### Examples of Proper File Deletion
```bash
# ✅ GOOD: Remove single file with git rm
git rm unused_module.py

# ✅ GOOD: Remove directory recursively with git rm
git rm -r deprecated_directory/

# ✅ GOOD: Remove multiple files with git rm
git rm file1.py file2.py file3.py

# ✅ GOOD: Remove with commit message
git rm old_config.yaml && git commit -m "cleanup: remove deprecated configuration file"

# ❌ BAD: Remove with regular rm (doesn't update Git, creates orphaned files)
rm unused_module.py

# ❌ BAD: Remove directory with regular rm (doesn't update Git)
rm -rf deprecated_directory/

# ❌ BAD: Need separate git add after regular rm (extra steps, risk of forgetting)
rm file.py
git add -A  # Extra step needed, easy to forget
```

#### **MANDATORY**: Deletion Workflow
1. **Use git rm**: `git rm filename` or `git rm -r directory/`
2. **Verify deletion**: Check `git status` to confirm deletion is staged
3. **Commit with context**: `git commit -m "cleanup: remove [reason for deletion]"`
4. **Verify completion**: Check `git log` to confirm deletion is recorded

#### **MANDATORY**: Deletion Commit Messages
Use descriptive commit messages that explain WHY the file was removed:

```bash
# ✅ GOOD: Clear reason for deletion
git commit -m "cleanup: remove deprecated brush_yaml directory after consolidation"

# ✅ GOOD: Specific about what was removed
git commit -m "cleanup: remove unused test fixtures and mock data"

# ✅ GOOD: Context about replacement
git commit -m "cleanup: remove old configuration files replaced by new format"

# ❌ BAD: Generic deletion message
git commit -m "cleanup: remove files"

# ❌ BAD: No context about why
git commit -m "cleanup: delete stuff"
```

#### **MANDATORY**: Deletion Validation
After deleting files, **ALWAYS** validate that the deletion was successful:

```bash
# 1. Check git status to confirm deletion is staged
git status

# 2. Verify file is actually removed from filesystem
ls -la filename  # Should show "No such file or directory"

# 3. Check that no broken references remain
grep -r "deleted_filename" . --include="*.py" --exclude-dir=.git

# 4. Run tests to ensure no functionality was broken
make test-fast

# 5. Commit the deletion (git rm automatically stages the deletion)
git commit -m "cleanup: remove [filename] - [reason]"

# 6. Verify no orphaned files remain in Git
git ls-files | grep filename  # Should return nothing if properly deleted
```

#### **MANDATORY**: Deletion Safety Checks
Before deleting files, **ALWAYS** perform these safety checks:

1. **Check for references**: `grep -r "filename" . --include="*.py"`
2. **Check imports**: Look for `import filename` or `from filename`
3. **Check documentation**: Look for references in docs and README files
4. **Check configuration**: Look for references in config files
5. **Run tests**: Ensure deletion doesn't break existing functionality
6. **Use git rm**: **NEVER** use regular `rm` - always use `git rm` to prevent orphaned files

#### **MANDATORY**: Deletion Rollback
If deletion causes issues, **ALWAYS** know how to rollback:

```bash
# Rollback last commit (if deletion was just committed)
git reset --soft HEAD~1

# Restore specific file from previous commit
git checkout HEAD~1 -- filename

# Restore entire directory from previous commit
git checkout HEAD~1 -- directory/

# Commit the restoration
git commit -m "fix: restore [filename] - deletion caused [issue]"
```

#### **MANDATORY**: Deletion Categories
Use appropriate commit types for different deletion scenarios:

```bash
# cleanup: for removing unused/dead code
git commit -m "cleanup: remove unused imports and dead code"

# refactor: for removing deprecated features
git commit -m "refactor: remove deprecated knot_maker field"

# fix: for removing broken/problematic code
git commit -m "fix: remove broken configuration that caused errors"

# data: for removing data files
git commit -m "data: remove outdated catalog entries"
```

#### **MANDATORY**: Deletion Documentation
When deleting files that might be referenced elsewhere, **ALWAYS** document the deletion:

```bash
# Add to commit message or create documentation
git commit -m "cleanup: remove deprecated brush_yaml directory

- Consolidated all brush data into single brushes.yaml file
- Updated all references to use new consolidated structure
- Removed redundant brush_yaml/ subdirectory
- All functionality preserved in new structure"
```

#### **MANDATORY**: Deletion in Refactoring
When refactoring involves file deletions, **ALWAYS** use git rm:

```bash
# Example: Consolidating multiple files into one
# 1. Create new consolidated file
# 2. Update all references to use new file
# 3. Remove old files with git rm
git rm old_file1.py old_file2.py old_file3.py

# 4. Commit the consolidation
git commit -m "refactor: consolidate [files] into [new_file] for better organization"
```

#### **MANDATORY**: Deletion in Cleanup
When cleaning up unused code, **ALWAYS** use git rm:

```bash
# Example: Removing unused test files
git rm tests/test_unused_feature.py

# Example: Removing unused data files
git rm data/old_catalog.yaml

# Example: Removing unused documentation
git rm docs/deprecated_spec.md

# Commit cleanup
git commit -m "cleanup: remove unused files and dead code"
```

### **MANDATORY**: Use `git mv` for ALL Moves and Renames
When moving or renaming files in the repository, **ALWAYS** use `git mv` instead of `mv` to ensure proper Git tracking and history preservation. This applies to ALL file moves and renames, not just Git operations.

#### **MANDATORY**: File Move/Rename Commands
- ✅ **Use**: `git mv oldname newname` - Moves/renames file and stages change
- ✅ **Use**: `git mv olddir/ newdir/` - Moves/renames directory
- ✅ **Use**: `git mv file1 file2 file3 destdir/` - Moves multiple files to directory
- ❌ **Don't use**: `mv oldname newname` - Moves file but doesn't update Git
- ❌ **Don't use**: `mv olddir/ newdir/` - Moves directory but doesn't update Git

#### **MANDATORY**: Git Mv Benefits
- **Proper tracking**: Git knows the file was intentionally moved/renamed
- **History preservation**: File history is maintained in Git
- **Staging**: Move/rename is automatically staged for commit
- **Clean commits**: No need for separate `git add` after move/rename
- **Revert capability**: Can easily revert move/rename if needed
- **No orphaned files**: Prevents files from remaining in Git history when moved from filesystem
- **Consistent state**: Ensures Git repository state matches filesystem state
- **Blame tracking**: Maintains file history and blame information across moves

#### Examples of Proper File Move/Rename
```bash
# ✅ GOOD: Rename single file with git mv
git mv old_module.py new_module.py

# ✅ GOOD: Move file to different directory with git mv
git mv src/old_file.py dest/new_file.py

# ✅ GOOD: Rename directory with git mv
git mv old_directory/ new_directory/

# ✅ GOOD: Move multiple files with git mv
git mv file1.py file2.py file3.py dest_directory/

# ✅ GOOD: Move with commit message
git mv old_config.yaml new_config.yaml && git commit -m "refactor: rename configuration file for clarity"

# ❌ BAD: Move with regular mv (doesn't update Git, creates orphaned files)
mv old_module.py new_module.py

# ❌ BAD: Move directory with regular mv (doesn't update Git)
mv old_directory/ new_directory/

# ❌ BAD: Need separate git add after regular mv (extra steps, risk of forgetting)
mv file.py dest/
git add -A  # Extra step needed, easy to forget
```

#### **MANDATORY**: Move/Rename Workflow
1. **Use git mv**: `git mv oldname newname` or `git mv olddir/ newdir/`
2. **Verify move/rename**: Check `git status` to confirm change is staged
3. **Commit with context**: `git commit -m "refactor: move/rename [reason for change]"`
4. **Verify completion**: Check `git log` to confirm move/rename is recorded

#### **MANDATORY**: Move/Rename Commit Messages
Use descriptive commit messages that explain WHY the file was moved/renamed:

```bash
# ✅ GOOD: Clear reason for move/rename
git commit -m "refactor: move brush matcher to specialized strategies directory"

# ✅ GOOD: Specific about what was moved/renamed
git commit -m "refactor: rename config files for better organization and clarity"

# ✅ GOOD: Context about reorganization
git commit -m "refactor: consolidate utility modules into unified utils package"

# ❌ BAD: Generic move/rename message
git commit -m "refactor: move files"

# ❌ BAD: No context about why
git commit -m "refactor: rename stuff"
```

#### **MANDATORY**: Move/Rename Validation
After moving/renaming files, **ALWAYS** validate that the change was successful:

```bash
# 1. Check git status to confirm move/rename is staged
git status

# 2. Verify file is actually moved/renamed in filesystem
ls -la newname  # Should show the file exists
ls -la oldname  # Should show "No such file or directory"

# 3. Check that no broken references remain
grep -r "oldname" . --include="*.py" --exclude-dir=.git

# 4. Update any imports or references to use new name
# (This is often needed after move/rename)

# 5. Run tests to ensure no functionality was broken
make test-fast

# 6. Commit the move/rename (git mv automatically stages the change)
git commit -m "refactor: move/rename [oldname] to [newname] - [reason]"

# 7. Verify no orphaned files remain in Git
git ls-files | grep oldname  # Should return nothing if properly moved
```

#### **MANDATORY**: Move/Rename Safety Checks
Before moving/renaming files, **ALWAYS** perform these safety checks:

1. **Check for references**: `grep -r "filename" . --include="*.py"`
2. **Check imports**: Look for `import filename` or `from filename`
3. **Check documentation**: Look for references in docs and README files
4. **Check configuration**: Look for references in config files
5. **Run tests**: Ensure move/rename doesn't break existing functionality
6. **Use git mv**: **NEVER** use regular `mv` - always use `git mv` to prevent orphaned files
7. **Plan import updates**: Identify all files that need import updates after move/rename

#### **MANDATORY**: Move/Rename Rollback
If move/rename causes issues, **ALWAYS** know how to rollback:

```bash
# Rollback last commit (if move/rename was just committed)
git reset --soft HEAD~1

# Restore specific file from previous commit
git checkout HEAD~1 -- oldname

# Restore entire directory from previous commit
git checkout HEAD~1 -- olddir/

# Commit the restoration
git commit -m "fix: restore [oldname] - move/rename caused [issue]"
```

#### **MANDATORY**: Move/Rename Categories
Use appropriate commit types for different move/rename scenarios:

```bash
# refactor: for reorganizing code structure
git commit -m "refactor: move brush strategies to specialized directory for better organization"

# feat: for moving files as part of new feature
git commit -m "feat: move API handlers to dedicated handlers module"

# docs: for reorganizing documentation
git commit -m "docs: reorganize documentation into logical sections"

# data: for reorganizing data files
git commit -m "data: consolidate catalog files into unified structure"
```

#### **MANDATORY**: Move/Rename Documentation
When moving/renaming files that might be referenced elsewhere, **ALWAYS** document the change:

```bash
# Add to commit message or create documentation
git commit -m "refactor: move brush matching strategies to specialized directory

- Moved brush strategies from generic matchers/ to specialized brush_matching_strategies/
- Updated all imports to use new module paths
- Improved organization for better maintainability
- All functionality preserved in new structure"
```

#### **MANDATORY**: Move/Rename in Refactoring
When refactoring involves file moves/renames, **ALWAYS** use git mv:

```bash
# Example: Reorganizing module structure
# 1. Create new directory structure
mkdir -p new_module_structure/

# 2. Move files with git mv
git mv old_module/file1.py new_module_structure/file1.py
git mv old_module/file2.py new_module_structure/file2.py

# 3. Update imports in all affected files
# (This is often the most time-consuming part)

# 4. Commit the reorganization
git commit -m "refactor: reorganize module structure for better organization"
```

#### **MANDATORY**: Move/Rename in Cleanup
When cleaning up involves file moves/renames, **ALWAYS** use git mv:

```bash
# Example: Consolidating scattered files
git mv scattered_file1.py unified_directory/
git mv scattered_file2.py unified_directory/

# Example: Renaming for clarity
git mv confusing_name.py clear_name.py

# Example: Moving to appropriate location
git mv misplaced_config.yaml config/

# Commit cleanup
git commit -m "refactor: consolidate and rename files for better organization"
```

#### **MANDATORY**: Import Updates After Move/Rename
After moving/renaming files, **ALWAYS** update all imports:

```bash
# 1. Find all files that import the moved/renamed file
grep -r "from old_module" . --include="*.py"
grep -r "import old_module" . --include="*.py"

# 2. Update imports to use new path
# Example: from old_module import function -> from new_module import function

# 3. Test that imports work correctly
python -c "import new_module"  # Should not raise ImportError

# 4. Run tests to ensure no functionality was broken
make test-fast
```

- Remove redundant files when consolidating data structures
- Update imports when moving or removing modules
- Clean up unused test fixtures and mock data
- Remove deprecated code paths after refactoring

## Refactoring Cleanup Checklist
When removing or consolidating code:

1. **Search for all references** using grep/ripgrep
2. **Update imports** in affected modules
3. **Remove unused test files** and fixtures
4. **Update .gitignore** if file patterns change
5. **Check for broken imports** with `make typecheck`
6. **Run full test suite** to catch integration issues
7. **Update documentation** if APIs change

## Temporary File Management
- Use `tmp_path` fixture in tests for temporary files
- Clean up generated test data in teardown
- Don't commit temporary debugging files
- Use descriptive names for temporary variables (avoid `temp`, `tmp`)

## Code Removal Best Practices
```python
# Before removing a function/class, check usage:
# grep -r "function_name" . --include="*.py"

# When removing fields from data structures:
# 1. Update all tests that reference the field
# 2. Update documentation/specs
# 3. Check for serialization/deserialization code
# 4. Verify no downstream consumers depend on the field

# Example: Removing knot_maker field
# ✓ Remove from strategy return values
# ✓ Remove from test assertions  
# ✓ Update documentation
# ✓ Check for any enrichment code using the field
```

## Dependency Cleanup
- Remove unused imports at the top of files
- Use `ruff --fix` to automatically remove unused imports
- Check for unused dependencies in requirements.txt
- Remove commented-out code blocks

## Data Migration Patterns
When consolidating data files:

```python
# Pattern for migrating from multiple files to single file
def migrate_brush_data():
    """Example: Consolidating brush_yaml/* into brushes.yaml"""
    old_files = [
        "data/brush_yaml/known_brushes.yaml",
        "data/brush_yaml/other_brushes.yaml",
        "data/brush_yaml/dg_brushes.yaml"
    ]
    
    consolidated = {}
    for file_path in old_files:
        if Path(file_path).exists():
            with open(file_path) as f:
                data = yaml.safe_load(f)
                consolidated.update(data)
    
    # Write consolidated file
    with open("data/brushes.yaml", "w") as f:
        yaml.dump(consolidated, f, default_flow_style=False)
```

## Commit Message Patterns
- `feat:` for new features
- `fix:` for bug fixes  
- `refactor:` for code restructuring
- `test:` for test changes
- `docs:` for documentation
- `cleanup:` for removing unused code/files

Examples:
- `cleanup: remove redundant brush_yaml folder and consolidate into brushes.yaml`
- `refactor: remove knot_maker field as redundant with brand`
- `fix: correct handle_maker key naming in brush matcher tests`

Examples:
- `cleanup: remove redundant brush_yaml folder and consolidate into brushes.yaml`
- `refactor: remove knot_maker field as redundant with brand`
- `fix: correct handle_maker key naming in brush matcher tests`

- `refactor: remove knot_maker field as redundant with brand`
- `fix: correct handle_maker key naming in brush matcher tests`
