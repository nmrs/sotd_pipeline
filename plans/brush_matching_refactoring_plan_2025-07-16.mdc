# Brush Matching Code Refactoring Plan

## üìò Project Summary

Refactor the monolithic `BrushMatcher` class (1,088 lines) into focused, maintainable components following SOLID principles. The current implementation has grown complex with multiple responsibilities, duplicated logic, and deep nesting that makes it difficult to test, maintain, and extend.

**Goals:**
- Split the god object into focused, single-responsibility components
- Improve testability through better separation of concerns
- Reduce code duplication and complexity
- Maintain existing functionality while improving structure
- Create reusable components for future enhancements

**Current State:**
- `BrushMatcher` class: 1,088 lines with multiple responsibilities
- Complex nested logic in `match()` method (200+ lines)
- Duplicated loading and error handling logic
- Scattered caching implementation
- Hard-coded configuration management

**Target State:**
- Focused components with clear responsibilities
- Improved error handling and logging
- Centralized configuration management
- Better caching strategy
- Enhanced testability and maintainability

## üß© Component Steps

### Phase 1: Foundation and Configuration
1. **Configuration Management** - Extract configuration into dedicated class
2. **Caching Strategy** - Implement centralized caching system
3. **Error Handling** - Create structured error types and handling

### Phase 2: Data Loading and Management
4. **Catalog Loading** - Extract unified catalog loading logic
5. **Correct Matches Checker** - Separate correct matches validation
6. **Data Structures** - Create typed data structures for better type safety

### Phase 3: Core Matching Logic
7. **Matching Orchestrator** - Extract main matching coordination logic
8. **Match Extractor** - Separate match result extraction and standardization
9. **Post Processor** - Extract post-processing and enrichment logic

### Phase 4: Integration and Testing
10. **Component Integration** - Wire all components together
11. **Backward Compatibility** - Ensure existing API remains unchanged
12. **Testing and Validation** - Update tests and validate functionality

## üîÅ Implementation Prompts

### Step 1: Configuration Management

```text
Create a configuration management system for the brush matcher to replace hard-coded paths and settings.

**Requirements:**
- Create `BrushMatcherConfig` dataclass with all configuration parameters
- Add validation for required paths and settings
- Support both default and custom configurations
- Include debug mode and other settings

**Implementation:**
1. Create `sotd/match/config.py` with `BrushMatcherConfig` dataclass
2. Add path validation in `__post_init__`
3. Include all current constructor parameters as config fields
4. Add helper methods for common configuration operations
5. Update `BrushMatcher` constructor to accept config object

**Key Features:**
- Type-safe configuration with dataclass
- Automatic path validation
- Support for both default and custom paths
- Debug mode and other settings
- Helper methods for common operations

**Files to Create/Modify:**
- `sotd/match/config.py` (new)
- `sotd/match/brush_matcher.py` (update constructor)

**Example Usage:**
```python
config = BrushMatcherConfig(
    catalog_path=Path("data/brushes.yaml"),
    handles_path=Path("data/handles.yaml"),
    knots_path=Path("data/knots.yaml"),
    correct_matches_path=Path("data/correct_matches.yaml"),
    debug=True
)
matcher = BrushMatcher(config)
```

Ensure the configuration system is flexible enough to support future enhancements while maintaining backward compatibility.
```

### Step 2: Caching Strategy

```text
Implement a centralized caching system to replace the scattered cache implementation in BrushMatcher.

**Requirements:**
- Create `MatchCache` class with LRU-style eviction
- Support different cache key strategies
- Include cache statistics and debugging
- Make caching optional and configurable

**Implementation:**
1. Create `sotd/match/cache.py` with `MatchCache` class
2. Implement LRU eviction with configurable max size
3. Add cache key builders for different operations
4. Include cache statistics and debug information
5. Make cache optional and configurable via config

**Key Features:**
- LRU eviction with configurable max size
- Consistent cache key generation
- Cache statistics and debugging
- Optional caching with config control
- Thread-safe operations

**Files to Create/Modify:**
- `sotd/match/cache.py` (new)
- `sotd/match/config.py` (add cache settings)
- `sotd/match/brush_matcher.py` (integrate cache)

**Example Usage:**
```python
cache = MatchCache(max_size=1000)
cache.set("correct_matches:value", result)
cached_result = cache.get("correct_matches:value")
```

Ensure the caching system is efficient and doesn't impact performance while providing clear debugging capabilities.
```

### Step 3: Error Handling

```text
Create structured error handling for brush matching operations to replace generic exception handling.

**Requirements:**
- Define specific exception types for different error scenarios
- Create error context and debugging information
- Implement graceful error recovery where appropriate
- Add error logging and reporting

**Implementation:**
1. Create `sotd/match/exceptions.py` with custom exception hierarchy
2. Define specific exceptions for catalog loading, matching, and validation errors
3. Add error context and debugging information to exceptions
4. Implement graceful error recovery strategies
5. Add error logging and reporting capabilities

**Key Features:**
- Hierarchical exception types
- Rich error context and debugging information
- Graceful error recovery strategies
- Comprehensive error logging
- User-friendly error messages

**Files to Create/Modify:**
- `sotd/match/exceptions.py` (new)
- `sotd/match/brush_matcher.py` (update error handling)

**Exception Hierarchy:**
```python
class BrushMatchingError(Exception): pass
class CatalogLoadError(BrushMatchingError): pass
class InvalidMatchDataError(BrushMatchingError): pass
class ConfigurationError(BrushMatchingError): pass
```

Ensure error handling provides clear debugging information while maintaining graceful operation in production.
```

### Step 4: Catalog Loading

```text
Extract unified catalog loading logic to replace the duplicated loading methods in BrushMatcher.

**Requirements:**
- Create `CatalogLoader` class with unified loading logic
- Support loading of brushes, handles, knots, and correct matches
- Implement consistent error handling and validation
- Add loading statistics and debugging

**Implementation:**
1. Create `sotd/match/loaders.py` with `CatalogLoader` class
2. Implement unified YAML loading with consistent error handling
3. Add validation for loaded data structures
4. Include loading statistics and debugging information
5. Support loading of all required catalogs

**Key Features:**
- Unified YAML loading with consistent error handling
- Data structure validation
- Loading statistics and debugging
- Support for all catalog types
- Graceful handling of missing or corrupted files

**Files to Create/Modify:**
- `sotd/match/loaders.py` (new)
- `sotd/match/brush_matcher.py` (integrate loader)

**Example Usage:**
```python
loader = CatalogLoader(config)
catalog_data = loader.load_all_catalogs()
```

Ensure the loading system is robust and provides clear error messages for debugging.
```

### Step 4.5: Remove Dynamic Batch Processing

```text
Remove dynamic batch processing behavior from YAML files and pattern compilation logic to simplify the codebase.

**Requirements:**
- Remove `{batch}` placeholder expansion from YAML pattern definitions
- Remove `valid_batches` configuration from YAML files
- Simplify pattern compilation logic in brush/knot matching strategies
- Clean up any batch-related code in pattern processing

**Implementation:**
1. Remove `{batch}` placeholders from all YAML pattern definitions (requires user permission for YAML changes)
2. Remove `valid_batches` sections from YAML configuration files (requires user permission for YAML changes)
3. Simplify pattern compilation in `known_knot_strategy.py` and other strategies
4. Remove batch expansion logic from pattern processing
5. Update any tests that rely on batch processing behavior

**Key Features:**
- Simplified YAML configuration without dynamic expansion
- Cleaner pattern compilation logic
- Reduced complexity in matching strategies
- More predictable and maintainable code

**Files to Create/Modify:**
- `data/brushes.yaml` (remove batch placeholders and valid_batches - requires user permission)
- `data/knots.yaml` (remove batch placeholders and valid_batches - requires user permission)
- `sotd/match/brush_matching_strategies/known_knot_strategy.py` (simplify pattern compilation)
- Update any other strategy files with batch processing logic
- Update tests that rely on batch processing

**Example Changes:**
```yaml
# Before (complex with batch processing)
patterns:
  - pattern: "Declaration Grooming B{batch}"
    valid_batches: ["1", "2", "3", "4", "5"]

# After (simplified)
patterns:
  - pattern: "Declaration Grooming B1"
  - pattern: "Declaration Grooming B2"
  - pattern: "Declaration Grooming B3"
  - pattern: "Declaration Grooming B4"
  - pattern: "Declaration Grooming B5"
```

Ensure the removal simplifies the codebase while maintaining all existing matching functionality.
```

### Step 5: Correct Matches Checker

```text
Extract correct matches checking logic into a focused component to simplify the main matching flow.

**Requirements:**
- Create `CorrectMatchesChecker` class with focused responsibility
- Implement efficient lookup strategies
- Support both brush and handle/knot section checking
- Add caching and performance optimization

**Implementation:**
1. Create `sotd/match/correct_matches.py` with `CorrectMatchesChecker` class
2. Implement efficient lookup strategies for different section types
3. Add caching for frequently accessed correct matches
4. Include debugging and performance monitoring
5. Support both simple and combo brush checking

**Key Features:**
- Focused responsibility for correct matches checking
- Efficient lookup strategies
- Caching for performance
- Support for different match types
- Clear debugging information

**Files to Create/Modify:**
- `sotd/match/correct_matches.py` (new)
- `sotd/match/brush_matcher.py` (integrate checker)

**Example Usage:**
```python
checker = CorrectMatchesChecker(config, catalog_data)
if match := checker.check(value):
    return process_correct_match(value, match)
```

Ensure the correct matches checking is efficient and provides clear debugging information.
```

### Step 6: Data Structures

```text
Create typed data structures to improve type safety and code clarity throughout the brush matching system.

**Requirements:**
- Define dataclasses for match results, catalog data, and configuration
- Add type hints throughout the codebase
- Improve code clarity and IDE support
- Enable better static analysis

**Implementation:**
1. Create `sotd/match/types.py` with dataclasses for all data structures
2. Define types for match results, catalog data, and configuration
3. Add comprehensive type hints throughout the codebase
4. Include validation and helper methods for data structures
5. Enable better IDE support and static analysis

**Key Features:**
- Type-safe data structures with dataclasses
- Comprehensive type hints
- Validation and helper methods
- Better IDE support and static analysis
- Clear data flow throughout the system

**Files to Create/Modify:**
- `sotd/match/types.py` (new)
- Update all brush matching files with type hints

**Data Structures:**
```python
@dataclass
class MatchResult:
    original: str
    matched: Optional[dict]
    match_type: Optional[str]
    pattern: Optional[str]

@dataclass
class CatalogData:
    brushes: dict
    handles: dict
    knots: dict
    correct_matches: dict
```

Ensure the type system provides clear contracts and enables better tooling support.
```

### Step 7: Matching Orchestrator

```text
Extract the main matching coordination logic into a focused orchestrator component.

**Requirements:**
- Create `MatchingOrchestrator` class to coordinate matching strategies
- Implement the main matching workflow logic
- Support different matching strategies and priorities
- Add performance monitoring and debugging

**Implementation:**
1. Create `sotd/match/orchestrator.py` with `MatchingOrchestrator` class
2. Implement the main matching workflow from the current `match()` method
3. Support different matching strategies and priorities
4. Add performance monitoring and debugging capabilities
5. Integrate with existing strategy pattern

**Key Features:**
- Focused responsibility for matching coordination
- Support for different matching strategies
- Performance monitoring and debugging
- Clear workflow logic
- Integration with existing components

**Files to Create/Modify:**
- `sotd/match/orchestrator.py` (new)
- `sotd/match/brush_matcher.py` (integrate orchestrator)

**Example Usage:**
```python
orchestrator = MatchingOrchestrator(config, components)
result = orchestrator.match(value)
```

Ensure the orchestrator provides clear workflow logic and integrates well with existing components.
```

### Step 8: Match Extractor

```text
Extract match result extraction and standardization logic into a focused component.

**Requirements:**
- Create `MatchExtractor` class to handle result extraction and standardization
- Support different result formats from strategies
- Implement catalog data enrichment
- Add validation and error handling

**Implementation:**
1. Create `sotd/match/extractor.py` with `MatchExtractor` class
2. Implement result extraction and standardization logic
3. Support different result formats from strategies
4. Add catalog data enrichment capabilities
5. Include validation and error handling

**Key Features:**
- Focused responsibility for result extraction
- Support for different result formats
- Catalog data enrichment
- Validation and error handling
- Clear result standardization

**Files to Create/Modify:**
- `sotd/match/extractor.py` (new)
- `sotd/match/brush_matcher.py` (integrate extractor)

**Example Usage:**
```python
extractor = MatchExtractor(catalog_data)
match_dict = extractor.extract(result, strategy)
```

Ensure the extractor provides clear result standardization and handles different input formats gracefully.
```

### Step 9: Post Processor

```text
Extract post-processing and enrichment logic into a focused component.

**Requirements:**
- Create `PostProcessor` class to handle result enrichment and post-processing
- Implement fiber resolution, handle/knot subsections, and maker resolution
- Support different enrichment strategies
- Add performance monitoring and debugging

**Implementation:**
1. Create `sotd/match/post_processor.py` with `PostProcessor` class
2. Implement result enrichment and post-processing logic
3. Support different enrichment strategies
4. Add performance monitoring and debugging capabilities
5. Integrate with existing fiber and handle processing

**Key Features:**
- Focused responsibility for result enrichment
- Support for different enrichment strategies
- Performance monitoring and debugging
- Integration with existing components
- Clear enrichment workflow

**Files to Create/Modify:**
- `sotd/match/post_processor.py` (new)
- `sotd/match/brush_matcher.py` (integrate processor)

**Example Usage:**
```python
processor = PostProcessor(config, components)
result = processor.process(result, value)
```

Ensure the post processor provides clear enrichment logic and integrates well with existing components.
```

### Step 10: Component Integration

```text
Wire all the new components together in the main BrushMatcher class while maintaining the existing API.

**Requirements:**
- Integrate all new components into the main BrushMatcher class
- Maintain backward compatibility with existing API
- Ensure proper component initialization and configuration
- Add comprehensive error handling and logging

**Implementation:**
1. Update `BrushMatcher` constructor to use new components
2. Integrate all new components with proper initialization
3. Maintain backward compatibility with existing API
4. Add comprehensive error handling and logging
5. Ensure proper component communication and data flow

**Key Features:**
- Backward compatibility with existing API
- Proper component integration
- Comprehensive error handling
- Clear component communication
- Maintained functionality

**Files to Create/Modify:**
- `sotd/match/brush_matcher.py` (major refactor)

**Example Usage:**
```python
# Existing API should continue to work
matcher = BrushMatcher()  # Uses default config
result = matcher.match("Declaration Grooming B2")

# New API with custom config
config = BrushMatcherConfig(debug=True)
matcher = BrushMatcher(config)
result = matcher.match("Declaration Grooming B2")
```

Ensure the integration maintains all existing functionality while providing the benefits of the new component structure.
```

### Step 11: Backward Compatibility

```text
Ensure complete backward compatibility with existing code and tests while introducing the new component structure.

**Requirements:**
- Maintain all existing public API methods and signatures
- Preserve all existing functionality and behavior
- Update tests incrementally as components are extracted
- Add comprehensive testing for new components
- Document any behavioral changes or improvements

**Implementation:**
1. Verify all existing public API methods are preserved
2. Update tests incrementally as internal structure changes
3. Add comprehensive tests for new components
4. Validate all existing functionality is maintained
5. Document any changes or improvements

**Key Features:**
- Complete backward compatibility for public API
- Incremental test updates as structure changes
- Comprehensive testing of new components
- Preserved functionality and behavior
- Clear documentation of changes

**Files to Create/Modify:**
- Update test files incrementally as components are extracted
- Add new test files for new components
- Update documentation as needed

**Testing Strategy:**
- Update tests incrementally during refactoring (Steps 1-9)
- Ensure all tests pass by final integration (Step 10)
- Add unit tests for each new component
- Add integration tests for component interactions
- Add performance tests for new caching system

**Behavioral Assumptions:**
- Public API remains identical
- Return values and data structures unchanged
- Error handling maintains same user-facing behavior
- Performance improvements are transparent
- Internal debugging may be enhanced

Ensure all existing functionality is preserved while providing the benefits of the new component structure.
```

### Step 12: Testing and Validation

```text
Comprehensive testing and validation of the refactored brush matching system.

**Requirements:**
- Update existing tests to work with new component structure
- Add comprehensive tests for all new components
- Validate performance improvements and caching effectiveness
- Ensure error handling and edge cases are properly tested

**Implementation:**
1. Update existing tests to work with new component structure
2. Add comprehensive unit tests for all new components
3. Add integration tests for component interactions
4. Add performance tests for caching and optimization
5. Validate error handling and edge cases

**Key Features:**
- Comprehensive test coverage
- Performance validation
- Error handling validation
- Edge case testing
- Integration testing

**Files to Create/Modify:**
- Update all existing test files
- Add new test files for new components
- Add performance and integration tests

**Testing Areas:**
- Unit tests for each new component
- Integration tests for component interactions
- Performance tests for caching system
- Error handling and edge case tests
- Backward compatibility tests

Ensure comprehensive testing validates all functionality and performance improvements.
```

## üß† Critical Analysis

### Strengths of This Plan

1. **Incremental Approach**: Each step builds logically on the previous one, minimizing risk
2. **Backward Compatibility**: Maintains existing API throughout the refactoring
3. **Clear Separation**: Each component has a single, well-defined responsibility
4. **Testability**: New structure enables better unit testing and isolation
5. **Performance**: Caching and optimization improvements included
6. **Maintainability**: Smaller, focused components are easier to understand and modify

### Risk Mitigation

1. **Backward Compatibility**: Each step preserves existing functionality
2. **Incremental Testing**: Tests updated incrementally as structure changes
3. **Component Isolation**: New components can be tested independently
4. **Clear Interfaces**: Well-defined contracts between components
5. **Error Handling**: Comprehensive error handling prevents silent failures
6. **Behavioral Preservation**: Public API and user-facing behavior unchanged

### Expected Benefits

1. **Maintainability**: Smaller, focused components are easier to understand
2. **Testability**: Each component can be tested in isolation
3. **Reusability**: Components can be reused in different contexts
4. **Performance**: Better caching and optimization strategies
5. **Clarity**: Clear separation of concerns makes the code easier to follow
6. **Extensibility**: New features can be added more easily

### Implementation Notes

- **Order Matters**: Steps must be implemented in sequence due to dependencies
- **Testing Strategy**: Update tests at each step to ensure no regressions
- **Documentation**: Update documentation as components are created
- **Performance Monitoring**: Monitor performance impact of each change
- **Error Handling**: Ensure comprehensive error handling throughout

This refactoring plan provides a clear path to transform the monolithic brush matcher into a well-structured, maintainable system while preserving all existing functionality and improving overall code quality.

---

## üìã Implementation Checklist

### Phase 1: Foundation and Configuration
- [x] Step 1: Configuration Management
- [x] Step 2: Caching Strategy  
- [x] Step 3: Error Handling

### Phase 2: Data Loading and Management
- [ ] Step 4: Catalog Loading
- [x] Step 4.5: Remove Dynamic Batch Processing
- [x] Step 5: Correct Matches Checker
- [ ] Step 6: Data Structures

### Phase 3: Core Matching Logic
- [ ] Step 7: Matching Orchestrator
- [ ] Step 8: Match Extractor
- [ ] Step 9: Post Processor

### Phase 4: Integration and Testing
- [ ] Step 10: Component Integration
- [ ] Step 11: Backward Compatibility
- [ ] Step 12: Testing and Validation

---

## üìù Session Notes

### Session 1: [Date] - Plan Creation
- Created comprehensive refactoring plan following non-TDD project planning format
- Identified 12 incremental steps across 4 phases
- Established clear goals and success criteria
- Defined risk mitigation strategies and expected benefits

### Session 2: [2024-07-14] - Step 1 Complete
- Implemented BrushMatcherConfig dataclass in `sotd/match/config.py` with validation and helper methods
- Updated `BrushMatcher` to accept config object, maintaining backward compatibility
- Added unit tests for configuration system
- All existing and new tests pass, type/lint/format checks clean
- Ready to proceed to Step 2: Caching Strategy

### Session 3: [2024-07-14] - Step 2 Complete
- Implemented `MatchCache` class in `sotd/match/cache.py` with LRU eviction, statistics, and debug info
- Integrated `MatchCache` into `BrushMatcher`, replacing old dict-based cache
- All cache usage now goes through the new interface, controlled by config
- All tests, lint, and type checks pass
- Ready to proceed to Step 3: Error Handling

### Session 4: [2024-07-14] - Step 3 Complete
- Created custom exception hierarchy in `sotd/match/exceptions.py` with context support
- Updated `BrushMatcher` to use specific exception types (`CatalogLoadError`) instead of generic exceptions
- Replaced bare `except Exception:` with specific exception types for better error handling
- Added rich context information to error messages for better debugging
- Maintained fail-fast approach for internal errors while adding graceful handling for external errors
- Added comprehensive tests for all exception types
- All tests, lint, and type checks pass
- Ready to proceed to Phase 2: Data Loading and Management

### Session 5: [2025-01-27] - Step 4.5 Complete
- Removed dynamic batch processing functionality from the codebase
- Deleted `sotd/utils/yaml_preprocessor.py` (unused YAML preprocessor with batch expansion)
- Simplified `KnownKnotMatchingStrategy` by removing `_compile_template_patterns` method and batch pattern logic
- Removed batch processing test from `test_known_knot_strategy.py`
- Updated test name in `test_complete_brush_catalog.py` to be more accurate
- Verified no YAML files were modified (as requested)
- All tests pass (1528 tests)
- All quality checks pass (format, lint, typecheck)
- Codebase simplified by removing unused complexity
- Ready to proceed to Step 5: Correct Matches Checker

### Session 6: [2025-01-27] - Step 5 Complete
- Created `CorrectMatchesChecker` class in `sotd/match/correct_matches.py` with focused responsibility
- Implemented efficient lookup strategies for brush section and handle/knot section checking
- Added comprehensive statistics and debugging capabilities
- Integrated `CorrectMatchesChecker` into `BrushMatcher`, replacing scattered correct matches logic
- Removed old correct matches checking methods from `BrushMatcher` (simplified by ~150 lines)
- Added comprehensive test suite with 16 test cases covering all functionality
- All tests pass (1544 tests, including 16 new tests)
- All quality checks pass (format, lint, typecheck)
- Component provides clear separation of concerns and better testability
- Ready to proceed to Step 6: Data Structures

---

## üéØ Success Criteria

- [ ] All existing tests pass (with incremental updates during refactoring)
- [ ] Public API remains identical and backward compatible
- [ ] New component structure is well-tested and documented
- [ ] Performance is maintained or improved
- [ ] Code is more maintainable and easier to understand
- [ ] Error handling maintains same user-facing behavior
- [ ] Internal debugging and error reporting is enhanced
description:
globs:
alwaysApply: false
---

## Follow-up Cleanup: Standardize Strategy Return Types

**Issue:**
During the incremental refactor, some matching strategies and utility functions still return plain dicts, while the new code expects a standardized result type (MatchResult). Temporary dual-mode compatibility code (handling both dict and MatchResult) was added to keep the pipeline working during migration.

**Action Required:**
- Audit all brush, knot, and handle matching strategies and utilities to ensure they return only the standardized MatchResult type.
- Update all helpers (e.g., create_strategy_result) to return MatchResult, not dict.
- Remove all dual-mode compatibility code from orchestrators and matchers.
- Add type checks/tests to enforce this contract.

**Rationale:**
This will complete the standardization goal of the refactor, improve maintainability, and prevent subtle bugs from mixed return types.

**Priority:**
High (should be addressed immediately after the main refactor is complete and tests are passing).
