# TDD Project Plan: Unify Normalization Logic for Correct Match Lookups

## Overview

**Goal:** Ensure that all correct match lookups (in matchers, analyzers, and any other consumers) use a single, canonical normalization function (`normalize_for_matching`). This will guarantee that any string stored in `correct_matches.yaml` will always be found as an exact match if the input is normalized the same way, eliminating "confirmed but not exact" mismatches.

**Problem:** Currently, the matcher and analyzer use different normalization logic, causing strings in `correct_matches.yaml` to not be found as exact matches during processing, leading to confusing "confirmed but not exact" results.

**Solution:** Centralize all normalization logic into a single `normalize_for_matching` function and ensure all components use it consistently.

## Implementation Plan

### Phase 1: Audit and Foundation (Chunks 1-2)

#### Chunk 1.1: Audit Current Normalization Logic
- [ ] Search codebase for all normalization logic in matchers, base classes, and analyzer
- [ ] Document differences and overlaps between implementations
- [ ] Identify all places where normalization is performed for correct match lookups
- [ ] Create a comprehensive list of normalization inconsistencies

#### Chunk 1.2: Create Failing Test Foundation
- [ ] Write a failing test that iterates over all entries in `correct_matches.yaml`
- [ ] For each entry, assert that the matcher finds it as an exact match
- [ ] This test should fail initially, proving the normalization inconsistency
- [ ] Add test to verify analyzer and matcher agree on what constitutes an exact match

#### Chunk 2.1: Refactor Canonical Normalization Function
- [ ] Rename `normalize_for_storage` to `normalize_for_matching`
- [ ] Update function to handle all field-specific normalization needs (razor, blade, brush, soap)
- [ ] Add comprehensive docstrings explaining this is the canonical normalization for correct match lookups
- [ ] Ensure all field-specific quirks are handled (handle stripping for razors, blade count patterns, etc.)

#### Chunk 2.2: Expand Normalization Tests
- [ ] Add/expand tests for edge cases and field-specific normalization
- [ ] Test normalization consistency across different input formats
- [ ] Add tests for competition tag stripping, handle indicators, blade patterns, etc.
- [ ] Ensure normalization is deterministic and consistent

### Phase 2: Update Matchers (Chunk 3)

#### Chunk 3.1: Update BaseMatcher
- [ ] Modify `BaseMatcher` to use `normalize_for_matching(field=...)` for all correct match lookups
- [ ] Update `_check_correct_matches` method to use canonical normalization
- [ ] Remove or refactor any custom normalization methods that duplicate logic
- [ ] Add tests to verify BaseMatcher uses canonical normalization

#### Chunk 3.2: Update All Matcher Subclasses
- [ ] Update `RazorMatcher` to use `normalize_for_matching(field="razor")`
- [ ] Update `BladeMatcher` to use `normalize_for_matching(field="blade")`
- [ ] Update `BrushMatcher` to use `normalize_for_matching(field="brush")`
- [ ] Update `SoapMatcher` to use `normalize_for_matching(field="soap")`
- [ ] Remove any custom normalization logic in each matcher
- [ ] Add tests for each matcher to verify correct match lookups work properly

#### Chunk 3.3: Update Match Phase Integration
- [ ] Ensure `run.py match` uses the updated matchers correctly
- [ ] Test that match phase produces consistent results with canonical normalization
- [ ] Verify that exact matches are properly identified and marked

### Phase 3: Update Analyzer and Other Consumers (Chunk 4)

#### Chunk 4.1: Update Mismatch Analyzer
- [ ] Ensure `MismatchAnalyzer` uses `normalize_for_matching` everywhere
- [ ] Update `_create_match_key` method to use canonical normalization
- [ ] Update `_load_correct_matches` method to use canonical normalization
- [ ] Add tests to verify analyzer uses canonical normalization consistently

#### Chunk 4.2: Update Other Tools and Scripts
- [ ] Update any other tools that perform correct match lookups
- [ ] Update `CorrectMatchesManager` if it exists
- [ ] Update any utility scripts that normalize strings for matching
- [ ] Add tests for all updated components

### Phase 4: Integration and Regression Testing (Chunk 5)

#### Chunk 5.1: Comprehensive Integration Tests
- [ ] Run the full test suite to ensure no regressions
- [ ] Add regression tests for previously "confirmed but not exact" cases
- [ ] Test that the 4 problematic cases from the original issue are now resolved
- [ ] Verify that all existing exact matches still work correctly

#### Chunk 5.2: End-to-End Validation
- [ ] Add a comprehensive test that iterates over all entries in `correct_matches.yaml`
- [ ] For each entry, assert that the matcher finds it as an exact match
- [ ] Test with real data from recent months to ensure no regressions
- [ ] Verify that the mismatch analyzer shows 0 "confirmed but not exact" cases

### Phase 5: Documentation and Cleanup (Chunk 6)

#### Chunk 6.1: Update Documentation
- [ ] Update developer documentation to state that `normalize_for_matching` is the only allowed normalization for correct match lookups
- [ ] Add clear examples of how to use the canonical normalization function
- [ ] Document the field-specific normalization rules (handle stripping, blade patterns, etc.)
- [ ] Update any relevant README files or technical documentation

#### Chunk 6.2: Code Cleanup and Comments
- [ ] Add comments in code where normalization is performed, referencing the canonical function
- [ ] Remove any dead code or outdated normalization utilities
- [ ] Ensure all imports are updated to use the new function name
- [ ] Add deprecation warnings for old function names if needed

#### Chunk 6.3: Final Validation
- [ ] Run complete quality checks: `make format lint typecheck test`
- [ ] Verify that all tests pass, including the new comprehensive tests
- [ ] Test with real pipeline data to ensure end-to-end functionality
- [ ] Document any lessons learned or edge cases discovered

## Success Criteria

1. **Zero "confirmed but not exact" mismatches**: All strings in `correct_matches.yaml` are found as exact matches by the matcher
2. **Single source of truth**: All normalization logic uses `normalize_for_matching`
3. **Comprehensive test coverage**: Tests verify normalization consistency across all components
4. **No regressions**: All existing functionality continues to work correctly
5. **Clear documentation**: Developers understand how to use the canonical normalization function

## Risk Mitigation

- **Incremental approach**: Each chunk builds on the previous, allowing for early detection of issues
- **Comprehensive testing**: Extensive test coverage ensures no regressions
- **Backward compatibility**: Maintain existing function signatures where possible
- **Documentation**: Clear documentation prevents future inconsistencies

## Dependencies

- Existing `normalize_for_storage` function in `sotd/utils/match_filter_utils.py`
- Current matcher implementations in `sotd/match/`
- Mismatch analyzer in `sotd/match/tools/analyzers/`
- Test infrastructure and quality check tools

## Timeline Estimate

- **Phase 1**: 2-3 chunks (audit + foundation)
- **Phase 2**: 1 chunk (matcher updates)
- **Phase 3**: 1 chunk (analyzer updates)
- **Phase 4**: 1 chunk (integration testing)
- **Phase 5**: 1 chunk (documentation + cleanup)

**Total**: 6 chunks, estimated 2-3 development sessions

## Notes

- This refactor addresses the core issue where normalization logic was scattered and inconsistent
- The rename from `normalize_for_storage` to `normalize_for_matching` better reflects the function's broader purpose
- All changes should be made incrementally with comprehensive testing at each step
- The goal is to eliminate the confusing "confirmed but not exact" results by ensuring consistent normalization
description:
globs:
alwaysApply: false
---
