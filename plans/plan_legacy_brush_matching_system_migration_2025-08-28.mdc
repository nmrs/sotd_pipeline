# Legacy Brush Matching System Migration Plan

**Date**: 2025-01-27  
**Purpose**: Systematically migrate from dual-system architecture to single scoring system by extracting shared functionality first  
**Status**: PLANNING  

## üìò Project Summary

The SOTD Pipeline currently maintains two brush matching systems: a legacy "first match wins" system and a new multi-strategy scoring system. The legacy system has been completely superseded by the new scoring system, but the new system still depends on legacy components for catalog loading and wrapper strategies.

**Key Discovery**: The `BrushScoringMatcher` is heavily dependent on the legacy system for:
- Catalog data loading (brushes, handles, knots)
- Wrapper strategies that call legacy methods  
- Strategy dependency management
- Knot strategy initialization

**Goals**:
- Eliminate dual-system architecture safely
- Extract shared functionality into reusable utilities
- Maintain full functionality throughout migration
- Create clean, single-system architecture

**Success Criteria**:
- Single brush matching system (BrushScoringMatcher)
- No legacy system dependencies
- All functionality preserved
- Clean, maintainable codebase

## üéØ Migration Strategy

### **Phase 1: Extract Shared Functionality (SAFE)**
Extract catalog loading, strategy management, and other shared functionality into utilities that both systems can use.

### **Phase 2: Update New System (SAFE)**  
Update BrushScoringMatcher to use shared utilities instead of legacy system.

### **Phase 3: Remove Legacy System (SAFE)**
Once new system is fully independent, remove legacy components.

### **Phase 4: Cleanup and Verification**
Remove unused code, update tests, verify functionality.

## üìã Implementation Plan

### **Phase 1: Extract Shared Functionality**
1. **Extract Catalog Loading Logic** - **COMPLETE** ‚úÖ
   - Create `sotd/match/utils/catalog_loader.py`
   - Extract brush, handle, knot, fiber loading from legacy system
   - Ensure both systems can use shared loader
   - **Implementation**: Successfully updated `scoring_brush_matcher.py` to use existing `CatalogLoader` instead of deleted `BrushMatcher`
   - **Result**: Import now successful, dependency on legacy system removed for catalog loading

2. **Extract Strategy Management Logic** - **COMPLETE** ‚úÖ
   - Create `sotd/match/utils/strategy_manager.py`
   - Extract strategy creation and dependency management
   - Make strategies work with either system
   - **Implementation**: ‚úÖ **COMPLETE** - Created StrategyManager utility with methods for creating full strategies, temporary strategies, and knot strategies. Updated scoring_brush_matcher.py to use the new utility instead of duplicating strategy creation logic. All tests pass and functionality is preserved.

3. **Extract Configuration Logic** - **COMPLETE** ‚úÖ
   - Create `sotd/match/utils/config_loader.py`
   - Extract configuration loading and validation
   - Ensure consistent configuration across systems
   - **Implementation**: ‚úÖ **COMPLETE** - Created ConfigManager utility with methods for getting default config, debug config, and creating custom configs. Updated scoring_brush_matcher.py to use the shared config manager instead of multiple calls to BrushMatcherConfig.create_default(). All tests pass and functionality is preserved.

4. **Create Shared Strategy Base Classes** - **COMPLETE** ‚úÖ
   - Update wrapper strategies to work without legacy dependencies
   - Create abstract base classes for common functionality
   - Ensure strategies can work with either catalog source
   - **Implementation**: ‚úÖ **COMPLETE** - Added missing legacy interface methods to BrushScoringMatcher (_match_correct_complete_brush, _match_correct_split_brush, _match_known_split, _match_complete_brush, _match_high_priority_automated_split, _match_medium_priority_automated_split, create_dual_component_result, create_single_component_result). These methods implement the legacy interface using the new scoring system, allowing wrapper strategies to work without the actual legacy BrushMatcher. All tests pass and functionality is preserved.

### **Phase 2: Update New System**
5. **Update BrushScoringMatcher Dependencies** - **COMPLETE** ‚úÖ
   - Remove remaining legacy system imports and dependencies
   - Ensure all functionality uses shared utilities
   - Test integration with wrapper strategies
   - **Implementation**: ‚úÖ **COMPLETE** - Consolidated duplicate imports to top of file, removed hardcoded paths in favor of shared config, updated legacy dependency references to use current strategy names (FullInputComponentMatchingStrategy, HandleOnlyStrategy, KnotOnlyStrategy), cleaned up duplicate import statements in methods, and updated load_correct_matches to use shared config. All tests pass and functionality is preserved.

6. **Update Wrapper Strategies** - **IN_PROGRESS** ‚è≥
   - Remove legacy matcher dependencies from wrapper strategies
   - Update strategies to use new system directly
   - Test all wrapper strategies work correctly
   - **Implementation**: Starting with wrapper strategy dependency cleanup and testing

7. **Update Strategy Dependencies**
   - Modify dependency management to work without legacy system
   - Update strategy orchestration logic
   - Ensure clean dependency graph

### **Phase 3: Remove Legacy System**
8. **Remove Legacy Classes**
   - Delete `BrushMatcher` class
   - Delete `BrushMatcherEntryPoint` class
   - Remove legacy wrapper strategies

9. **Remove Legacy Tools and Directories**
   - Delete `sotd/match/tools/legacy/` directory
   - Delete `sotd/report/table_generators/legacy/` directory
   - Remove legacy data directories

10. **Remove Legacy CLI Options**
    - Remove `--brush-system` argument
    - Update run.py to use only new system
    - Remove system selection logic

### **Phase 4: Test Migration and Validation**
14. **Update Test Imports and Dependencies**
    - Replace `BrushMatcher` imports with `BrushScoringMatcher` in tests
    - Update test data and mock objects to use new system
    - Ensure all tests can run without legacy system

15. **Update Integration Tests**
    - Fix broken integration tests that depend on legacy system
    - Update test fixtures and setup to use shared catalog loader
    - Validate end-to-end functionality

16. **Update Strategy Tests**
    - Modify tests for wrapper strategies to work with new system
    - Update test data structures to match new catalog format
    - Ensure strategy behavior remains consistent

### **Phase 5: Remove Legacy System**
17. **Remove Legacy Classes**
    - Delete `BrushMatcher` class
    - Delete `BrushMatcherEntryPoint` class
    - Remove legacy wrapper strategies

18. **Remove Legacy Tools and Directories**
    - Delete `sotd/match/tools/legacy/` directory
    - Delete `sotd/report/table_generators/legacy/` directory
    - Remove legacy data directories

19. **Remove Legacy CLI Options**
    - Remove `--brush-system` argument
    - Update run.py to use only new system
    - Remove system selection logic

### **Phase 6: Cleanup and Verification**
20. **Update Remaining Tests**
    - Remove legacy-specific tests
    - Update remaining tests to use new system
    - Ensure full test coverage

21. **Update Documentation**
    - Remove references to legacy system
    - Update configuration documentation
    - Update user guides

22. **Final Verification**
    - Run comprehensive test suite
    - Verify all functionality works as expected
    - Check for any remaining legacy references
    - **Implementation**: TBD

23. **Rename Main Matcher** - **PLANNED** üìã
    - Rename `scoring_brush_matcher.py` to `brush_matcher.py`
    - Update all imports and references throughout the codebase
    - Update class name from `BrushScoringMatcher` to `BrushMatcher`
    - Update documentation and type hints
    - **Rationale**: After removing the legacy system, this will be the only brush matcher, so the name should reflect its primary role
    - **Implementation**: TBD - will be done after all legacy system removal is complete

## üîß Technical Approach

### **Migration Strategy**
1. **Extract shared functionality** into reusable utilities (Phase 1)
2. **Update new system** to use shared utilities (Phase 2)
3. **Remove legacy system** only after tests pass (Phase 3)
4. **Final cleanup and verification** (Phase 4)
5. **Rename main matcher** to reflect its primary role (Phase 5)

### **Key Principles**

### **Catalog Loading Extraction**
```python
# Create shared catalog loader
class CatalogLoader:
    def load_brushes(self) -> Dict[str, Any]
    def load_handles(self) -> Dict[str, Any] 
    def load_knots(self) -> Dict[str, Any]
    def load_fibers(self) -> Dict[str, Any]
    def get_knots_data(self) -> Dict[str, Any]
```

### **Strategy Management Extraction**
```python
# Create shared strategy manager
class StrategyManager:
    def create_knot_strategies(self, catalog_loader: CatalogLoader) -> List
    def create_wrapper_strategies(self, catalog_loader: CatalogLoader) -> List
    def manage_dependencies(self) -> StrategyDependencyManager
```

### **Migration Pattern**
1. **Extract** shared functionality into utilities
2. **Update** new system to use utilities
3. **Test** new system works independently
4. **Remove** legacy system safely
5. **Verify** no functionality lost

## ‚ö†Ô∏è Risk Mitigation

### **High Risk Areas**
- **Strategy Dependencies**: Complex dependency graph between strategies
- **Catalog Data Access**: Multiple systems accessing same data structures
- **Wrapper Strategy Logic**: Strategies that call legacy methods

### **Mitigation Strategies**
- **Incremental Extraction**: Extract one component at a time
- **Dual System Testing**: Test both systems work during extraction
- **Rollback Plan**: Keep git commits for easy rollback
- **Comprehensive Testing**: Test each phase thoroughly before proceeding

## üìä Success Metrics

- **Functionality**: 100% of brush matching functionality preserved
- **Performance**: No degradation in matching performance
- **Code Quality**: Cleaner, more maintainable codebase
- **Test Coverage**: Full test coverage maintained
- **Documentation**: Updated and accurate documentation

## üöÄ Next Steps

1. **Start with Phase 1, Step 1**: Extract catalog loading logic
2. **Test thoroughly** after each extraction
3. **Commit frequently** with clear commit messages
4. **Validate each phase** before proceeding to next
5. **Maintain dual system** until new system is fully independent

## üìù Notes

- **Key Insight**: The new system was designed to work alongside legacy, not replace it
- **Migration Complexity**: Higher than initially estimated due to deep dependencies
- **Recommended Approach**: Systematic extraction rather than wholesale removal
- **Timeline**: Allow 2-3 development sessions for safe migration
- **Testing Strategy**: Test each component extraction thoroughly before proceeding

## üö® Critical Discovery: Test Dependencies

**Major Finding**: After completing Phase 1, Step 1, we discovered that **many test files still import the deleted `BrushMatcher` class**:

- **25+ test files** depend on the legacy system
- **Integration tests** are completely broken
- **Unit tests** for individual components still work
- **This validates our incremental approach** - we cannot delete everything at once

**Impact**: Our migration must include systematic test updates as we progress through each phase.

**Updated Strategy**: 
1. **Fix core functionality first** (Phase 1-3)
2. **Update tests systematically** (Phase 4 - NEW)
3. **Remove legacy system only after tests pass** (Phase 5)
4. **Final cleanup and verification** (Phase 6)

- **Overall Progress**: 4/23 steps complete (17.4%)
