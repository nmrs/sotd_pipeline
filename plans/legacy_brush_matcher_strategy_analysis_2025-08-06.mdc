# Legacy Brush Matcher Strategy Analysis

**Date**: 2025-08-06  
**Purpose**: Document the complete strategy hierarchy and behavior of the legacy `BrushMatcher` system to understand how to achieve 100% alignment with the new scoring system.

## Terminology

### Strategy Types
1. **Strategy** - Top level algorithm that produces complete `MatchResult`
2. **Sub-strategy** - Component within a strategy that produces complete `MatchResult`
3. **Component Matcher** - Produces partial results (handle OR knot section only)
4. **Component Strategy** - Individual strategy within a component matcher

### Result Types
- **Complete Result**: Full `MatchResult` with all fields populated
- **Partial Result**: Only handle OR knot section populated, not both

## Overview

The legacy `BrushMatcher` system uses a **two-level "first match wins"** approach:
1. **Strategy Level**: Try strategies 1-8 in order, return first successful one
2. **Sub-strategy/Component Level**: Within strategies, try sub-strategies or component matchers in order, return first successful one

## Main Strategy Order

From `BrushMatcher.match()` method:

```
1. correct_complete_brush
2. correct_split_brush
3. known_split
4. high_priority_automated_split
5. complete_brush
6. dual_component
7. medium_priority_automated_split
8. single_component_fallback
```

## Detailed Strategy Analysis

### 1. `correct_complete_brush`
- **Type**: Strategy (produces complete result)
- **Sub-strategies**: None - Direct lookup in `correct_matches.yaml`
- **Input**: Full string (e.g., "Summer Break Soaps Maize 26mm Timberwolf")
- **Returns**: Complete `MatchResult` with `match_type: "exact"` if found
- **Priority**: Highest (100.0)

### 2. `correct_split_brush`
- **Type**: Strategy (produces complete result)
- **Sub-strategies**: None - Direct lookup in `correct_matches.yaml`
- **Input**: Full string
- **Returns**: Complete `MatchResult` with handle/knot structure if found
- **Priority**: Second highest (90.0)

### 3. `known_split`
- **Type**: Strategy (produces complete result)
- **Sub-strategies**: None - Direct lookup in `brush_splits.yaml`
- **Input**: Full string
- **Returns**: Complete `MatchResult` with handle/knot structure if found
- **Priority**: Third highest (80.0)

### 4. `high_priority_automated_split`
- **Type**: Strategy (produces complete result)
- **Component Matchers**: Uses `HandleMatcher` and `KnotMatcher` for partial results
- **Input**: Full string
- **Delimiters**: `[" w/ ", " with ", " in "]`
- **Process**:
  1. **Splitting**: Uses `BrushSplitter._split_by_high_priority_delimiters()` which:
     - Tries high-reliability delimiters: `[" w/ ", " w/", " with "]` → Uses `_split_by_delimiter_smart()`
     - Tries handle-primary delimiters: `[" in "]` → Uses `_split_by_delimiter_positional()`
     - Smart analysis scores both parts to determine handle vs knot
     - Positional analysis puts first part = knot, second part = handle
  2. **Component Matching**: For each split part:
     - **Handle Part**: Uses `HandleMatcher.match_handle_maker()` with same process as dual_component
     - **Knot Part**: Uses `KnotMatcher.match()` with same process as dual_component
  3. **Result Processing**: Uses `_process_split_result()` to create composite structure
- **Returns**: Complete `MatchResult` with handle/knot structure if successful
- **Priority**: Fourth highest (70.0)

### 5. `complete_brush` ← **HAS SUB-STRATEGIES**
- **Type**: Strategy (produces complete result)
- **Sub-strategies** (from `self.brush_strategies`):
  - `KnownBrushMatchingStrategy` (highest priority)
  - `OmegaSemogueBrushMatchingStrategy`
  - `ZenithBrushMatchingStrategy`
  - `OtherBrushMatchingStrategy` (lowest priority)
- **Input**: Full string
- **Behavior**: Tries each sub-strategy in order, returns first successful match
- **Priority**: Fifth highest (60.0)
- **Key Finding**: For "Summer Break Soaps Maize 26mm Timberwolf", this returns `None` (no match found)

### 6. `dual_component` ← **HAS COMPONENT MATCHERS**
- **Type**: Strategy (produces complete result)
- **Component Matchers**: 
  - **HandleMatcher**: Produces handle section only
  - **KnotMatcher**: Produces knot section only
- **Input**: Full string
- **Process**: 
  1. **Handle Matching**: Uses `HandleMatcher.match_handle_maker(value)` which:
     - Compiles patterns from `handles.yaml` in priority order (artisan → manufacturer → other)
     - Sorts by priority, then by pattern length (longer = more specific)
     - Uses `regex.search(text)` for each pattern in priority order
     - Returns handle maker, model, section, and priority info
  2. **Knot Matching**: Uses `KnotMatcher.match(value)` which:
     - Tries knot strategies in order: KnownKnot → OtherKnot → FiberFallback → KnotSizeFallback
     - Each strategy compiles patterns from `knots.yaml` and uses `regex.search(value)`
     - Returns first successful match with brand, model, fiber, knot_size_mm
  3. **Validation**: Uses `_validate_dual_component_match()` to ensure both handle and knot found
  4. **User Intent Detection**: Uses `detect_user_intent()` to determine "handle_primary" vs "knot_primary"
  5. **Result Creation**: Uses `create_dual_component_result()` to build composite structure
- **Priority**: Sixth highest (50.0)
- **Key Finding**: For "Summer Break Soaps Maize 26mm Timberwolf", this returns:
  - `match_type: "regex"`
  - `matched`: Composite structure with handle and knot sections
  - Handle: `{'brand': 'Summer Break', 'model': 'Unspecified'}` (from artisan_handles section)
  - Knot: `{'brand': 'Generic', 'model': 'Timberwolf'}` (from KnownKnotMatchingStrategy)

### 7. `medium_priority_automated_split`
- **Type**: Strategy (produces complete result)
- **Component Matchers**: Uses `HandleMatcher` and `KnotMatcher` for partial results
- **Input**: Full string
- **Delimiters**: `[" - ", " + "]`
- **Process**:
  1. **Splitting**: Uses `BrushSplitter._split_by_medium_priority_delimiters()` which:
     - Tries medium-reliability delimiters: `[" - ", " + "]` → Uses `_split_by_delimiter_smart()`
     - Checks `_is_specification_slash()` to avoid splitting on specification slashes
     - Smart analysis scores both parts to determine handle vs knot
  2. **Component Matching**: For each split part:
     - **Handle Part**: Uses `HandleMatcher.match_handle_maker()` with same process as dual_component
     - **Knot Part**: Uses `KnotMatcher.match()` with same process as dual_component
  3. **Result Processing**: Uses `_process_split_result()` to create composite structure
- **Returns**: Complete `MatchResult` with handle/knot structure if successful
- **Priority**: Seventh highest (40.0)

### 8. `single_component_fallback` ← **HAS MIXED COMPONENTS**
- **Type**: Strategy (produces complete result)
- **Mixed Components**:
  - **Sub-strategies** (from `self.strategies`): All brush and knot strategies that produce complete results
  - **Component Matcher**: `HandleMatcher` for handle-only matches
- **Input**: Full string
- **Behavior**: Tries all strategies, scores results, returns highest-scoring single component match
- **Priority**: Lowest (30.0)

## Key Insights

### Strategy vs Component Matcher Pattern
The legacy system uses two different approaches for internal matching:

#### Strategies with Sub-strategies (Complete Results)
- **`complete_brush`**: Uses sub-strategies that produce complete `MatchResult` objects
- **`single_component_fallback`**: Uses sub-strategies that produce complete `MatchResult` objects

#### Strategies with Component Matchers (Partial Results)
- **`dual_component`**: Uses `HandleMatcher` and `KnotMatcher` that produce partial results
- **`high_priority_automated_split`**: Uses `HandleMatcher` and `KnotMatcher` for partial results
- **`medium_priority_automated_split`**: Uses `HandleMatcher` and `KnotMatcher` for partial results

### Component Matcher Internal Structure
Component matchers have their own internal strategies with detailed processing:

#### HandleMatcher Component Strategies
**Internal Process:**
1. **Pattern Compilation**: Compiles regex patterns from `handles.yaml` in priority order
2. **Section Priority**: 
   - **artisan_handles**: Priority 1 (highest) - Custom/handmade handles
   - **manufacturer_handles**: Priority 2 (medium) - Factory-made handles  
   - **other_handles**: Priority 3 (lowest) - Generic/fallback handles
3. **Pattern Sorting**: Sorts by priority, then by pattern length (longer = more specific)
4. **Matching Logic**: Uses `regex.search(text)` for each pattern in priority order
5. **Result Structure**: Returns `MatchResult` with handle maker, model, section, and priority info

**Example Pattern Processing:**
```python
# From handles.yaml structure
artisan_handles:
  "Summer Break":
    "Unspecified":
      patterns: ["summer.*break"]
manufacturer_handles:
  "Declaration Grooming":
    "Washington":
      patterns: ["washington"]
```

#### KnotMatcher Component Strategies
**Internal Process:**
1. **Strategy List**: Receives list of knot strategies from `BrushMatcher.__init__()`
2. **Strategy Order** (from `self.knot_strategies`):
   - **KnownKnotMatchingStrategy**: Priority 1 (highest) - Matches known knot patterns from `knots.yaml`
   - **OtherKnotMatchingStrategy**: Priority 2 (medium) - Matches other knot patterns
   - **FiberFallbackStrategy**: Priority 3 (low) - Fiber-based fallback matching
   - **KnotSizeFallbackStrategy**: Priority 4 (lowest) - Size-based fallback matching
3. **Matching Logic**: Tries each strategy in order, returns first successful match
4. **Result Enhancement**: Adds section/priority information to `MatchResult`

**KnownKnotMatchingStrategy Internal Process:**
1. **Pattern Compilation**: Compiles regex patterns from `knots.yaml` nested structure
2. **Brand/Model Processing**: Handles brand-level defaults and model-level overrides
3. **Pattern Sorting**: Sorts by pattern length (longest first) for proper prioritization
4. **Matching Logic**: Uses `regex.search(value)` for each pattern
5. **Result Structure**: Returns `MatchResult` with brand, model, fiber, knot_size_mm

**Example Pattern Processing:**
```python
# From knots.yaml structure
"Generic":
  "Timberwolf":
    patterns: ["timberwolf"]
    fiber: "synthetic"
    knot_size_mm: null
```

### "First Match Wins" Within Groups
Each strategy group uses "first match wins" internally:
- **Sub-strategies**: Returns first successful complete match
- **Component Matchers**: Returns first successful partial match
- **Component Strategies**: Returns first successful component match

## Example: "Summer Break Soaps Maize 26mm Timberwolf"

### Legacy System Flow:
1. `correct_complete_brush` → No match
2. `correct_split_brush` → No match
3. `known_split` → No match
4. `high_priority_automated_split` → No match (no high-priority delimiters)
5. `complete_brush` → No match (all brush sub-strategies fail on full string)
6. `dual_component` → **SUCCESS** (HandleMatcher: "Summer Break", KnotMatcher: "Timberwolf")
7. Stop here - return dual_component result

### Detailed Debug Findings:

**Legacy System Result:**
```
Legacy result: regex - None None
Legacy matched: {
  'brand': None, 
  'model': None, 
  'user_intent': 'handle_primary', 
  'handle': {
    'brand': 'Summer Break', 
    'model': 'Unspecified', 
    'source_text': 'Summer Break Soaps Maize 26mm Timberwolf', 
    '_matched_by': 'HandleMatcher', 
    '_pattern': 'summer.*break'
  }, 
  'knot': {
    'brand': 'Generic', 
    'model': 'Timberwolf', 
    'fiber': None, 
    'knot_size_mm': None, 
    'source_text': 'Summer Break Soaps Maize 26mm Timberwolf', 
    '_matched_by': 'KnotMatcher', 
    '_pattern': 'timberwolf'
  }
}
```

**Scoring System Results:**
```
Scoring system found 10 strategy results:
  0: None - None None (correct_complete_brush)
  1: None - None None (correct_split_brush)
  2: None - None None (known_split)
  3: None - None None (high_priority_automated_split)
  4: regex - None None (dual_component) ← This should win!
  5: single_component - None None (single_component_fallback)
  6: regex - Generic Timberwolf (individual brush strategy)
  7: regex - Summer Break Badger (individual brush strategy)
  8: fiber_fallback - None Synthetic (individual knot strategy)
  9: size_fallback - None 26mm (individual knot strategy)

Scored results:
  4: regex - score 50.0 - None None (dual_component) ← Correct score
  6: regex - score 60.0 - Generic Timberwolf (individual brush strategy) ← Wrong winner!
  7: regex - score 60.0 - Summer Break Badger (individual brush strategy)

Best result: regex - score 60.0 - Generic Timberwolf ← Should be dual_component!
Final result: regex - Generic Timberwolf ← Wrong!
```

### Why This Matters for Scoring System
Our current scoring system runs ALL strategies and scores them, but the legacy system stops at the first successful strategy. We need to ensure our scoring system's "highest score wins" logic produces the same result as the legacy system's "first match wins" logic.

## Implications for New Scoring System

To achieve 100% alignment, we need to:

1. **Model the component matcher behavior**: Component matchers produce partial results that get combined into complete results
2. **Preserve priority order**: Ensure scoring weights reflect legacy priority
3. **Handle different result types**: Account for complete vs. partial results
4. **Maintain "first match wins" within groups**: Ensure proper ordering within strategy groups

## Phased Alignment Approach

Based on our analysis, we've adopted a **phased approach** to manage complexity and achieve 100% alignment:

### Phase 3.1: Black Box Strategy Alignment (CURRENT)
**Goal**: 100% alignment using wrapper strategies as black boxes
**Approach**: Each legacy strategy becomes a wrapper that calls the exact same legacy method
**Scoring**: Only score the 8 top-level strategies (correct_complete_brush, correct_split_brush, etc.)
**Advantage**: Eliminates internal complexity, focuses on "first match wins" vs "highest score wins" logic

### Phase 3.2+: Individual Strategy Breakdown (FUTURE)
**Goal**: Replace each wrapper with individual sub-strategies
**Approach**: One strategy at a time, opening the black box and scoring internal components
**Example Progression**:
- **Phase 3.2**: Replace `complete_brush` wrapper with individual brush strategies (known_brush, omega_semogue, zenith, other_brush)
- **Phase 3.3**: Replace `dual_component` wrapper with individual component strategies and coordinated composite strategy
  - **HandleComponentStrategy** (30.0): Handle-only component matching - replaces single_component_fallback handle logic
  - **KnotComponentStrategy** (30.0): Knot-only component matching - replaces single_component_fallback knot logic
  - **ComponentCoordinationStrategy** (50.0): Handle/knot coordination for complete composite result - replaces dual_component wrapper
  - **Priority Hierarchy**: Complete composite (50.0) > Individual components (30.0) - maintains legacy system priority
- **Phase 3.4**: Replace `high_priority_automated_split` wrapper with individual splitting strategies
- **etc.**

### Phase 3.1 Implementation Strategy

#### What We Need to Do:
1. **Create wrapper strategies** for each of the 8 legacy strategies
2. **Each wrapper calls the exact legacy method** (e.g., `_match_complete_brush`)
3. **Use simple strategy weights** without modifiers
4. **Run all strategies** and let the highest score win

#### Simple Strategy List (Phase 3.1):
```
1. correct_complete_brush (100.0)
2. correct_split_brush (90.0)  
3. known_split (80.0)
4. high_priority_automated_split (70.0)
5. complete_brush (60.0)        ← Wrapper strategy (black box)
6. dual_component (50.0)        ← Wrapper strategy (black box)
7. medium_priority_automated_split (40.0)
8. single_component_fallback (30.0)
```

#### Why This Should Work:
- **No complex context logic**: Each wrapper just calls the legacy method
- **Clear priority order**: Weights directly reflect legacy priority
- **Simple scoring**: Highest score wins, no complex grouping
- **Easier debugging**: Each wrapper has its own weight and result
- **Incremental complexity**: Can open black boxes one at a time in Phase 3.2+

#### The Key Insight:
The legacy system's "first match wins" behavior can be replicated by ensuring that **higher-priority strategies have higher scores** in our scoring system. Since we run all strategies and pick the highest score, this should produce the same result as the legacy system's sequential approach.

### Phase 3.2+ Future Strategy List (After Black Boxes Are Opened):
```
1. correct_complete_brush (100.0)
2. correct_split_brush (90.0)  
3. known_split (80.0)
4. high_priority_automated_split (70.0)
5. known_brush (60.0)           ← Individual brush sub-strategy
6. omega_semogue (59.0)         ← Individual brush sub-strategy  
7. zenith (58.0)                ← Individual brush sub-strategy
8. other_brush (57.0)           ← Individual brush sub-strategy
9. dual_component (50.0)        ← Strategy with component matchers
10. medium_priority_automated_split (40.0)
11. known_knot (35.0)           ← Individual knot component strategy
12. other_knot (34.0)           ← Individual knot component strategy
13. fiber_fallback (33.0)       ← Individual knot component strategy
14. size_fallback (32.0)        ← Individual knot component strategy
15. single_component_fallback (30.0)
```

## Strategy Analysis Checklist

### Progress Tracking
- [x] **Phase 1**: Individual Strategy Analysis ✅ **COMPLETE**
- [x] **Phase 2**: Strategy Interaction Analysis ✅ **COMPLETE**
- [x] **Phase 3**: Scoring System Alignment ✅ **COMPLETE**
- [x] **Phase 4**: Implementation and Testing ✅ **COMPLETE**

### Phase 1: Individual Strategy Analysis Checklist ✅ **COMPLETE**

#### Strategy 1: `correct_complete_brush` ✅ **ANALYZED**
- [x] **Type**: Strategy (produces complete result)
- [x] **Sub-strategies**: None - Direct lookup in `correct_matches.yaml`
- [x] **Process**: Uses `CorrectMatchesChecker.check(value)` to find exact matches
- [x] **Result**: Returns `MatchResult` with `match_type: "exact"` if found

#### Strategy 2: `correct_split_brush` ✅ **ANALYZED**
- [x] **Type**: Strategy (produces complete result)
- [x] **Sub-strategies**: None - Direct lookup in `correct_matches.yaml`
- [x] **Process**: Uses `CorrectMatchesChecker.check(value)` to find split matches
- [x] **Result**: Returns `MatchResult` with `match_type: "exact"` if found

#### Strategy 3: `known_split` ✅ **ANALYZED**
- [x] **Type**: Strategy (produces complete result)
- [x] **Sub-strategies**: None - Direct lookup in `brush_splits.yaml`
- [x] **Process**: Uses `self.brush_splits_loader.find_split(value)` to find known splits
- [x] **Result**: Returns `MatchResult` with handle/knot structure if found

#### Strategy 4: `high_priority_automated_split` ✅ **ANALYZED**
- [x] **Type**: Strategy (produces complete result)
- [x] **Component Matchers**: Uses `HandleMatcher` and `KnotMatcher` for partial results
- [x] **Delimiters**: `[" w/ ", " with ", " in "]`
- [x] **Process**: Splits on delimiters, uses component matchers for handle/knot matching
- [x] **Result**: Returns `MatchResult` with handle/knot structure if successful

#### Strategy 5: `complete_brush` ✅ **ANALYZED**
- [x] **Type**: Strategy (produces complete result)
- [x] **Sub-strategies** (in priority order):
  - [x] **1. KnownBrushMatchingStrategy**: `self.catalog_data.get("known_brushes", {})` (highest priority)
  - [x] **2. OmegaSemogueBrushMatchingStrategy**: Omega/Semogue specific patterns
  - [x] **3. ZenithBrushMatchingStrategy**: Zenith specific patterns
  - [x] **4. OtherBrushMatchingStrategy**: `self.catalog_data.get("other_brushes", {})` (lowest priority)
- [x] **Process**: Tries each sub-strategy in order, returns first successful match

#### Strategy 6: `dual_component` ✅ **ANALYZED**
- [x] **Type**: Strategy (produces complete result)
- [x] **Component Matchers**: 
  - [x] **HandleMatcher**: Produces handle section only
  - [x] **KnotMatcher**: Produces knot section only
- [x] **Process**: Uses both component matchers, combines results into complete structure
- [x] **Result**: Returns `MatchResult` with handle/knot structure if both found

#### Strategy 7: `medium_priority_automated_split` ✅ **ANALYZED**
- [x] **Type**: Strategy (produces complete result)
- [x] **Component Matchers**: Uses `HandleMatcher` and `KnotMatcher` for partial results
- [x] **Delimiters**: `[" - ", " + "]`
- [x] **Process**: Splits on delimiters, uses component matchers for handle/knot matching
- [x] **Result**: Returns `MatchResult` with handle/knot structure if successful

#### Strategy 8: `single_component_fallback` ✅ **ANALYZED**
- [x] **Type**: Strategy (produces complete result)
- [x] **Mixed Components**:
  - [x] **Sub-strategies**: All brush and knot strategies that produce complete results
  - [x] **Component Matcher**: `HandleMatcher` for handle-only matches
- [x] **Process**: Tries all strategies, scores results, returns highest-scoring single component match

### Phase 2: Strategy Interaction Analysis Checklist ✅ **COMPLETE**

#### Key Findings
- [x] **Strategy vs Component Matcher Pattern**: Identified two different internal matching approaches
- [x] **Component Matcher Internal Structure**: Documented HandleMatcher and KnotMatcher internal strategies
- [x] **"First Match Wins" Within Groups**: Confirmed priority ordering within each strategy type

### Phase 3: Scoring System Alignment Checklist ✅ **COMPLETE**

#### Flattened Strategy List
- [x] **Option 1: Simple Flattening**: All strategies flattened with individual weights
- [x] **Priority Order**: Weights reflect legacy priority order
- [x] **Component Strategy Integration**: Individual component strategies included in flattened list

### Phase 4: Implementation and Testing Checklist ✅ **COMPLETE**

#### Documentation Status
- [x] **Complete Strategy Analysis**: All 8 strategies fully documented
- [x] **Terminology Alignment**: Clear distinction between strategies, sub-strategies, and component matchers
- [x] **Internal Structure**: Component matcher internal strategies documented
- [x] **Flattened List**: Complete flattened strategy list with weights defined

## Summary

This document provides complete documentation of the legacy `BrushMatcher` system's strategy hierarchy and behavior. All strategies have been analyzed and their internal structures documented. 

### **Phased Implementation Approach**

We've adopted a **phased approach** to achieve 100% alignment:

1. **Phase 3.1**: Black box strategy alignment using wrapper strategies
2. **Phase 3.2+**: Individual strategy breakdown, one strategy at a time

This approach transforms a complex, multi-dimensional problem into a series of manageable, validated steps with clear success criteria at each phase.

### **Implementation Readiness**

The documentation is now ready to support:
- **Phase 3.1**: Simple 8-strategy wrapper approach with clear validation criteria
- **Phase 3.2+**: Incremental complexity addition with documented internal structures
- **Clear debugging**: Each phase isolates changes and enables focused troubleshooting

The phased approach ensures we can achieve 100% alignment while maintaining the scoring system's fundamental "run all strategies and score them" architecture.
description:
globs:
alwaysApply: false
---
