# Blade Use Count Extraction Feature - TDD Implementation Plan

**Plan Date**: 2025-08-15  
**Type**: TDD Implementation Plan  
**Status**: READY_FOR_IMPLEMENTATION  

## Overview

This plan implements the blade use count extraction feature using Test-Driven Development (TDD) methodology. The feature will replace the existing `BladeCountEnricher` implementation with a new, priority-based extraction system that reuses existing patterns and adds validation logic.

## Goals

1. **Replace current `extract_blade_and_use_count` function** with improved implementation
2. **Reuse existing, tested patterns** from `extract_blade_count_strings.py`
3. **Implement priority logic layer** for consistent extraction behavior
4. **Add usage count validation** (critical business rule: <800 only)
5. **Maintain 99.8% pattern coverage** while improving accuracy
6. **Return integer values** instead of strings for better data quality

## TDD Approach

### **Test-First Development Cycle**
1. **Write failing test** for each feature/pattern
2. **Implement minimal code** to make test pass
3. **Refactor** for clarity and maintainability
4. **Repeat** for next feature/pattern

### **Test Structure**
- **Unit tests**: Test individual extraction functions
- **Integration tests**: Test complete extraction flow
- **Validation tests**: Test usage count validation logic
- **Edge case tests**: Test unusual but valid inputs

## Implementation Phases

### **Phase 0: Existing Test Coverage Analysis (Week 0 - Analysis Only)**

#### **0.1 Analyze Current Test Coverage**
**Goal**: Understand existing test coverage to avoid duplication and identify gaps

**Tasks**:
- [ ] Analyze `tests/enrich/test_blade_enricher.py` for existing test coverage
- [ ] Map existing test cases to planned functionality
- [ ] Identify test gaps and areas needing new coverage
- [ ] Document existing test patterns and approaches
- [ ] Evaluate test quality and coverage completeness

**Analysis to Perform**:
```python
# Review existing test coverage in test_blade_enricher.py
# Current tests cover:
# - Basic pattern extraction: (3), [4], {5}
# - Multiplier patterns: x4, 2x, (x2), (2X)
# - Case insensitivity: (X3), (x3)
# - Edge cases: whitespace, mixed text, multiple numbers
# - Integration: enricher.enrich() method
# - Real-world examples: 11 test cases with actual comment formats
```

**Test Coverage Mapping**:
- [ ] **Simple delimiters**: ✅ `(3)`, `[4]`, `{5}` - FULLY COVERED
- [ ] **Multiplier patterns**: ✅ `x4`, `2x`, `(x2)`, `(2X)` - FULLY COVERED  
- [ ] **Case insensitivity**: ✅ `(X3)`, `(x3)` - FULLY COVERED
- [ ] **Edge cases**: ✅ Whitespace, mixed text, multiple numbers - FULLY COVERED
- [ ] **Integration**: ✅ `enricher.enrich()` method - FULLY COVERED
- [ ] **Real-world examples**: ✅ 11 test cases - FULLY COVERED

**Gaps Identified**:
- [ ] **Priority logic**: No tests for pattern priority conflicts
- [ ] **Multiplier context**: No tests for blade_count vs use_count logic
- [ ] **Usage count validation**: No tests for <800 validation rule
- [ ] **New pattern types**: No tests for ordinal, hash, semantic patterns
- [ ] **Integer output**: Current tests expect string output, need integer validation

**Existing Test Quality Assessment**:
- **Coverage**: Comprehensive for current functionality
- **Structure**: Well-organized with clear test methods
- **Examples**: Good real-world test cases
- **Maintainability**: Clear test names and assertions

#### **0.2 Test Strategy Planning**
**Goal**: Plan testing approach based on existing coverage analysis

**Strategy**:
1. **Preserve existing tests**: Keep all current test cases working
2. **Extend existing tests**: Add new assertions for integer output
3. **Add new test categories**: Focus on gaps identified above
4. **Maintain test structure**: Follow existing test organization patterns

**Test Categories to Add**:
- **Priority logic tests**: Test pattern priority conflicts
- **Multiplier context tests**: Test blade_count vs use_count logic  
- **Validation tests**: Test usage count validation (<800 rule)
- **New pattern tests**: Test ordinal, hash, semantic patterns
- **Integration tests**: Test complete extraction flow

**Test Organization**:
- **Keep existing test methods**: Preserve current test structure
- **Add new test methods**: Follow existing naming conventions
- **Extend existing assertions**: Update string expectations to integer
- **Maintain test fixtures**: Keep existing enricher fixture

### **Phase 1: Pattern Extraction and Reuse (Week 1)**

#### **1.1 Extract Existing Pattern Logic**
**Goal**: Extract working patterns from `extract_blade_count_strings.py` into reusable functions

**Tasks**:
- [ ] Create `sotd/utils/blade_patterns.py` module
- [ ] Extract simple delimiter patterns: `(3)`, `[4]`, `{5}`
- [ ] Extract explicit usage patterns: `(3rd use)`, `(10th shave)`
- [ ] Extract multiplier patterns: `(2x)`, `(x3)`
- [ ] Extract hash number patterns: `#15`, `#2`
- [ ] Extract semantic patterns: `(NEW)`, `(fresh)`
- [ ] Extract month usage patterns: `15/31`, `20/31`
- [ ] Extract other pattern types

**Tests to Write First**:
```python
def test_extract_simple_delimiters():
    """Test extraction of (3), [4], {5} patterns."""
    assert extract_simple_delimiters("Astra SP (3)") == 3
    assert extract_simple_delimiters("Feather [4]") == 4
    assert extract_simple_delimiters("BIC {5}") == 5

def test_extract_explicit_usage():
    """Test extraction of (3rd use), (10th shave) patterns."""
    assert extract_explicit_usage("Astra (3rd use)") == 3
    assert extract_explicit_usage("Feather (10th shave)") == 10

def test_extract_multipliers():
    """Test extraction of (2x), (x3) patterns."""
    assert extract_multipliers("Astra (2x)") == 2
    assert extract_multipliers("Feather (x3)") == 3
```

**Success Criteria**:
- [ ] All existing patterns extracted and working
- [ ] 99.8% coverage maintained
- [ ] Unit tests passing for each pattern type

#### **1.2 Pattern Integration Testing**
**Goal**: Verify extracted patterns work correctly in new module

**Tasks**:
- [ ] Test pattern extraction against known data samples
- [ ] Validate pattern accuracy matches original implementation
- [ ] Test edge cases and unusual inputs
- [ ] Performance testing with large datasets

**Tests to Write First**:
```python
def test_pattern_integration():
    """Test that extracted patterns work together correctly."""
    # Test multiple patterns in same string
    # Test pattern priority when multiple exist
    # Test edge cases from real data
```

**Success Criteria**:
- [ ] All existing patterns extracted and working
- [ ] 99.8% coverage maintained
- [ ] Unit tests passing for each pattern type

#### **1.3 Update Existing Tests for Integer Output**
**Goal**: Modify existing tests to expect integer output instead of strings

**Tasks**:
- [ ] Update existing test assertions from string to integer expectations
- [ ] Preserve all existing test cases and coverage
- [ ] Ensure backward compatibility during transition
- [ ] Validate test structure and organization maintained

**Test Updates Required**:
```python
# Before (string output):
assert result["use_count"] == "3"

# After (integer output):
assert result["use_count"] == 3
```

**Tests to Update**:
- [ ] `test_enrich_with_parentheses_count` - change "3" to 3
- [ ] `test_enrich_with_brackets_count` - change "5" to 5
- [ ] `test_enrich_with_braces_count` - change "2" to 2
- [ ] `test_enrich_with_x_prefix` - change "4" to 4
- [ ] `test_enrich_with_x_suffix` - change "2" to 2
- [ ] All other existing test methods with string assertions

**Success Criteria**:
- [ ] All existing tests updated for integer output
- [ ] No test coverage lost during transition
- [ ] Test structure and organization preserved
- [ ] All tests passing with new integer format

### **Phase 2: Priority Logic Implementation (Week 2)**

#### **2.1 Core Extraction Function**
**Goal**: Implement main `extract_blade_counts()` function with priority logic

**Tasks**:
- [ ] Implement priority-based extraction flow
- [ ] Add simple delimiter priority (highest)
- [ ] Add multiplier context logic (blade_count vs use_count)
- [ ] Add fallback to lower priority patterns

**Tests to Write First**:
```python
def test_priority_logic():
    """Test that priority order is respected."""
    # Simple delimiters should win over other patterns
    assert extract_blade_counts("(2x) Astra (3)") == (2, 3)
    assert extract_blade_counts("Astra (3) #15") == (None, 3)

def test_multiplier_context():
    """Test multiplier context logic."""
    # If both patterns exist: multiplier = blade_count, simple = use_count
    assert extract_blade_counts("(2x) Astra (3)") == (2, 3)
    # If only multiplier: multiplier = use_count
    assert extract_blade_counts("Astra (3x)") == (None, 3)
```

**Success Criteria**:
- [ ] Priority logic correctly implemented
- [ ] Multiplier context logic working
- [ ] All test cases passing

#### **2.2 Usage Count Validation**
**Goal**: Implement critical business rule for realistic usage counts

**Tasks**:
- [ ] Implement `validate_usage_count()` function
- [ ] Add <800 validation rule
- [ ] Add 4+ digit validation rule
- [ ] Integrate validation into extraction flow

**Tests to Write First**:
```python
def test_usage_count_validation():
    """Test usage count validation logic."""
    # Valid ranges
    assert validate_usage_count(799) == 799  # Valid
    assert validate_usage_count(747) == 747  # Valid marathon
    # Invalid ranges
    assert validate_usage_count(800) is None  # Invalid
    assert validate_usage_count(3003135) is None  # Invalid model number

def test_validation_integration():
    """Test validation integrated with extraction."""
    # High numbers should return None
    assert extract_blade_counts("Feather (3003135)") == (None, None)
    # Valid numbers should work normally
    assert extract_blade_counts("Astra (3)") == (None, 3)
```

**Success Criteria**:
- [ ] Validation logic correctly implemented
- [ ] High numbers properly filtered out
- [ ] Valid marathon usage counts preserved

### **Phase 3: Enricher Integration (Week 3)**

#### **3.1 Update BladeCountEnricher**
**Goal**: Integrate new extraction function with existing enricher

**Tasks**:
- [ ] Update enricher to use new `extract_blade_counts()` function
- [ ] Change output format from strings to integers
- [ ] Maintain same output structure and metadata
- [ ] Test complete enrichment flow

**Tests to Write First**:
```python
def test_enricher_integration():
    """Test complete enricher integration."""
    enricher = BladeCountEnricher()
    result = enricher.enrich({}, "(2x) Astra (3)")
    
    assert result["blade_count"] == 2  # Integer, not string
    assert result["use_count"] == 3    # Integer, not string
    assert result["_enriched_by"] == "BladeCountEnricher"
    assert result["_extraction_source"] == "user_comment"

def test_enricher_output_format():
    """Test that output format matches requirements."""
    # Verify integers instead of strings
    # Verify same metadata structure
    # Verify validation working
```

**Success Criteria**:
- [ ] Enricher uses new extraction function
- [ ] Output format uses integers instead of strings
- [ ] All existing functionality preserved
- [ ] Integration tests passing

#### **3.2 End-to-End Testing**
**Goal**: Test complete pipeline with real data

**Tasks**:
- [ ] Test with actual SOTD data samples
- [ ] Validate extraction accuracy on real data
- [ ] Performance testing with large datasets
- [ ] Compare results with current implementation

**Tests to Write First**:
```python
def test_real_data_samples():
    """Test extraction with real SOTD data."""
    # Test known patterns from analysis
    # Test edge cases from real data
    # Test validation with high numbers

def test_performance():
    """Test performance with large datasets."""
    # Test processing time for 1000+ strings
    # Test memory usage
    # Test scalability
```

### **Phase 4: Quality Assurance and Documentation (Week 4)**

#### **4.1 Comprehensive Testing**
**Goal**: Ensure full test coverage and quality

**Tasks**:
- [ ] Complete unit test coverage
- [ ] Integration test coverage
- [ ] Edge case testing
- [ ] Performance validation

**Tests to Write First**:
```python
def test_edge_cases():
    """Test edge cases and unusual inputs."""
    # Empty strings, None values
    # Very long strings
    # Special characters
    # Mixed pattern types

def test_error_handling():
    """Test error handling and fail-fast behavior."""
    # Malformed input
    # Invalid regex patterns
    # Exception handling
```

#### **4.2 Documentation and Cleanup**
**Goal**: Complete documentation and code cleanup

**Tasks**:
- [ ] Update function docstrings
- [ ] Add inline comments
- [ ] Update README and documentation
- [ ] Code formatting and linting
- [ ] Final code review

## Testing Requirements

### **Unit Test Coverage**
- **Target**: 95%+ coverage for all new code
- **Pattern tests**: Test each pattern type individually
- **Priority tests**: Test priority logic and conflicts
- **Validation tests**: Test usage count validation
- **Edge case tests**: Test unusual but valid inputs

### **Integration Test Coverage**
- **Enricher integration**: Test complete enrichment flow
- **Pattern reuse**: Test extracted patterns work correctly
- **Real data validation**: Test with actual SOTD data
- **Performance validation**: Test with large datasets

### **Test Data Requirements**
- **Pattern coverage**: Test all documented pattern types
- **Priority validation**: Test pattern priority conflicts
- **Edge case validation**: Test complex, multi-pattern strings
- **Performance validation**: Test with representative data volumes

## Success Criteria

### **Quantitative Measures**
- **Pattern coverage**: Maintain 99.8% coverage from existing implementation
- **Test coverage**: 95%+ coverage for all new code
- **Accuracy**: 95%+ correct extraction rate on real data
- **Performance**: <100ms processing time per 1000 strings
- **Integration**: Seamless replacement of current enricher

### **Qualitative Measures**
- **Code quality**: Clean, maintainable implementation
- **Documentation**: Comprehensive technical documentation
- **Testing**: Full test coverage with clear test cases
- **Maintainability**: Easy to extend with new patterns

## Risk Mitigation

### **Technical Risks**
1. **Pattern extraction complexity**: Break down into small, testable functions
2. **Priority logic bugs**: Comprehensive testing of priority scenarios
3. **Performance degradation**: Profile and optimize critical paths

### **Integration Risks**
1. **Pattern compatibility**: Thorough testing with existing pattern data
2. **Output format changes**: Update all dependent code and validate

## Dependencies

### **Required Dependencies**
- Existing `extract_blade_count_strings.py` script (for pattern reuse)
- `sotd/enrich/blade_enricher.py` (for integration)
- `sotd/utils/` module structure (for new pattern module)

### **External Dependencies**
- Python 3.11+ (enforced by pyrightconfig.json)
- pytest for testing
- Existing test infrastructure

## Timeline

- **Week 0**: Existing test coverage analysis (analysis only)
- **Week 1**: Pattern extraction and reuse
- **Week 2**: Priority logic implementation
- **Week 3**: Enricher integration
- **Week 4**: Quality assurance and documentation

**Total Estimated Time**: 4 weeks + 1 week analysis
**Critical Path**: Analysis → Pattern extraction → Priority logic → Integration → Testing

## Next Steps

1. **Start with Phase 0**: Analyze existing test coverage in `test_blade_enricher.py`
2. **Plan test strategy**: Identify gaps and plan new test categories
3. **Proceed to Phase 1.1**: Extract existing pattern logic
4. **Write tests first** for each pattern type
5. **Iterate through phases** following TDD methodology
6. **Validate each phase** before proceeding to next

## Conclusion

This TDD implementation plan provides a structured approach to building the blade use count extraction feature. By following the test-first methodology and reusing existing patterns, we can ensure high quality, maintainable code while achieving the goal of replacing the current enricher with a significantly improved implementation.

The phased approach allows for iterative development and validation, ensuring each component works correctly before moving to the next phase. The focus on testing and validation will result in a robust, reliable feature that maintains the existing 99.8% pattern coverage while adding the new priority logic and validation capabilities.
description:
globs:
alwaysApply: false
---
