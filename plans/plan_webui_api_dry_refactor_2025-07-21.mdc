# WebUI & API DRY Refactor - TDD Implementation Plan

**Date**: 2025-07-21  
**Status**: DRAFT  
**Type**: Refactoring  
**Template**: TDD Project Planning  

## üìò Project Summary

Refactor the SOTD Pipeline webui and API to eliminate code duplication, centralize repeated logic (especially YAML/data file operations, error handling, and table/grid rendering), and ensure maintainability and testability. All changes must be test-driven and follow project rules for plan writing and testing.

---

## üß© Component Steps

### Phase 1: Shared Utilities for API (Python)

1. **YAML/Data File Utility Module** ‚úÖ COMPLETE
   - Create a shared utility for loading, saving, and validating YAML/data files.
   - Refactor all API modules to use these utilities for file I/O and validation.
   - **Implementation**: Created `webui/api/utils/yaml_utils.py` with comprehensive functions:
     - `load_yaml_file()` - Load YAML with error handling
     - `save_yaml_file()` - Save with atomic write
     - `validate_yaml_structure()` - Validate data types
     - `validate_required_fields()` - Check required fields
   - **Tests**: 18 comprehensive unit tests covering all functions and edge cases
   - **Refactoring**: Successfully refactored `brush_splits.py` to use new utilities
   - **Integration Tests**: 6 tests verifying the refactored module works correctly
   - **Quality**: All tests passing (24 total), linting clean, committed with clear message

2. **Centralized Error Handling**
   - Implement a decorator/context manager for API error handling.
   - Refactor endpoints to use this for consistent error responses.

3. **Base Validator Class**
   - Create a base validator for product-type validation logic.
   - Refactor product-specific validators to inherit from this.

---

### Phase 2: WebUI DRY Refactoring (React/TypeScript)

4. **Remove Manual Cache-Busting**
   - Ensure all cache-busting is handled by the Axios interceptor.
   - Remove manual timestamp query params from API calls.

5. **Generic DataTable Component**
   - Create a generic, configurable DataTable component.
   - Refactor all table/grid components to use this.

6. **Shared Form Field Components**
   - Create generic CheckboxField, SelectField, and InputField components.
   - Refactor forms to use these shared components.

7. **Generalize Data Transformers**
   - If multiple product types need transformation, create a generic transformer pattern.

---

### Phase 3: Testing and Documentation

8. **Test Utilities for Mocks**
   - Create test utilities for common mocks (API, fetch, months).
   - Refactor tests to use these utilities.

9. **Documentation**
   - Document all shared utilities and DRY patterns.
   - Update onboarding/contribution guides.

---

## üîÅ TDD Prompts for Each Step

### Step 1: YAML/Data File Utility Module

```text
Create a Python module (e.g., `webui/api/utils/yaml_utils.py`) with functions for loading, saving, and validating YAML/data files.  
- Write unit tests for all utility functions (load, save, validate, error cases).
- Refactor one API module (e.g., `brush_splits.py`) to use the new utility.
- Ensure all tests pass and error handling is consistent.
```

### Step 2: Centralized Error Handling

```text
Implement a decorator or context manager for API error handling in Python.  
- Write unit tests for the decorator/context manager (test various error types and responses).
- Refactor one endpoint to use the decorator.
- Ensure error responses are consistent and tests pass.
```

### Step 3: Base Validator Class

```text
Create a base validator class for product-type validation logic in Python.  
- Write unit tests for the base class (test required field validation, error cases).
- Refactor one product-specific validator to inherit from the base.
- Ensure all tests pass and logic is DRY.
```

### Step 4: Remove Manual Cache-Busting

```text
Audit all API calls in the webui for manual cache-busting query params.  
- Write a test that fails if manual `_t=` params are present in API calls.
- Refactor code to rely solely on the Axios interceptor.
- Ensure all tests pass and no manual cache-busting remains.
```

### Step 5: Generic DataTable Component

```text
Create a generic DataTable React component that accepts columns, data, and row renderers as props.  
- Write unit tests for the DataTable (renders columns, rows, handles empty data, etc.).
- Refactor one table component (e.g., `BrushSplitTable`) to use the generic DataTable.
- Ensure all tests pass and UI is unchanged.
```

### Step 6: Shared Form Field Components

```text
Create generic CheckboxField, SelectField, and InputField React components.  
- Write unit tests for each field component (renders, handles input, error states).
- Refactor one form to use the shared components.
- Ensure all tests pass and form behavior is unchanged.
```

### Step 7: Generalize Data Transformers

```text
If multiple product types require data transformation, create a generic transformer pattern in TypeScript.  
- Write unit tests for the generic transformer (handles various product types, error cases).
- Refactor one transformer to use the generic pattern.
- Ensure all tests pass and data is transformed correctly.
```

### Step 8: Test Utilities for Mocks

```text
Create test utility functions for common mocks (API, fetch, months) in the webui.  
- Write unit tests for the utilities.
- Refactor one test file to use the utilities.
- Ensure all tests pass and mocking is consistent.
```

### Step 9: Documentation

```text
Document all shared utilities and DRY patterns in the codebase.  
- Add or update documentation in `docs/` and code comments.
- Update onboarding/contribution guides to reference shared patterns.
- Ensure documentation is clear and up to date.
```

---

## üß™ Testing Requirements (per @sotd-pipeline-core.mdc)

- **Unit Tests**: Required for all new utilities, components, and refactored logic. List specific functions/components to be tested in each step.
- **Integration Tests**: Required for all refactored API endpoints and major UI flows. Specify real data files and workflow scenarios.
- **E2E Tests**: Optional, only for full user workflows (e.g., Playwright for UI, API integration for backend).
- **Test Coverage**: Minimum 90% for new/refactored code. All critical paths and error handling must be tested.
- **Error Handling**: All error scenarios must be tested (file not found, invalid data, API errors, etc.).
- **Performance**: Add performance tests for utilities/components that may impact load time or throughput.
- **Test File Locations**: Mirror source structure (e.g., `tests/api/test_yaml_utils.py`, `src/components/__tests__/DataTable.test.tsx`).
- **Mock Data**: Define and use mock data for all unit tests. Specify requirements in each step.
- **Test Execution**: Use `make format lint typecheck test` before commits. E2E: `npm run test:e2e:background` if needed.

---

## üß† Critical Analysis

- Each step is self-contained and test-first.
- No step produces orphaned or non-integrated code.
- Steps are small enough for safe, incremental progress.
- Prompts are ready for codegen or manual implementation.
- Plan is lean, avoids over-abstraction, and focuses on measurable DRY improvements.

---
description:
globs:
alwaysApply: false
---
