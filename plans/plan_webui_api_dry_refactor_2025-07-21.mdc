# WebUI & API DRY Refactor - TDD Implementation Plan

**Date**: 2025-07-21  
**Status**: IN_PROGRESS  
**Type**: Refactoring  
**Template**: TDD Project Planning  

## üìò Project Summary

Refactor the SOTD Pipeline webui and API to eliminate code duplication, centralize repeated logic (especially YAML/data file operations, error handling, and table/grid rendering), and ensure maintainability and testability. All changes must be test-driven and follow project rules for plan writing and testing.

---

## üìä Progress Summary

**Current Status**: Phase 1, Step 3 (YAML/Data File Utility Module) ‚úÖ COMPLETE  
**Next Step**: Phase 0, Step 1 (Fix WebUI Test Mocking Strategy) ‚è≥ PENDING  
**Overall Progress**: 1/11 steps complete (9%)  
**Blocking Issues**: 3 failing webui tests (pre-existing, not caused by our refactoring)

**Completed Work**:
- ‚úÖ Phase 1, Step 3: YAML/Data File Utility Module
  - Created comprehensive YAML utilities with 18 unit tests
  - Refactored brush_splits.py to use new utilities
  - Added 6 integration tests
  - All Python tests passing (1,724 tests)

**Immediate Next Steps**:
- ‚è≥ Phase 0, Step 1: Fix WebUI Test Mocking Strategy
  - Fix 3 failing webui tests with proper axios mocking
  - Separate unit tests from integration tests
  - Ensure all webui tests pass

---

## üß© Component Steps

### Phase 0: WebUI Test Infrastructure Fixes (Pre-Refactoring)

1. **Fix WebUI Test Mocking Strategy** ‚è≥ PENDING
   - **Issue**: Integration tests are hitting real API instead of using proper mocks
   - **Problem**: Tests expect specific data (2 items) but get real data (592 items)
   - **Solution**: Implement proper axios mocking for unit tests
   - **Implementation**:
     - Mock axios instead of fetch for API service tests
     - Separate unit tests (mocked) from integration tests (real API)
     - Fix `should_not_split` tests to use proper mocks
   - **Tests**: Ensure all webui tests pass (currently 3 failing)
   - **Quality**: Fast, reliable tests that don't depend on real API data

2. **Establish Test Data Isolation Strategy** ‚è≥ PENDING
   - **Issue**: Integration tests depend on changing production data
   - **Problem**: Tests fail when real data changes (592 items vs expected 2)
   - **Solution**: Create test-specific API endpoints with isolated data
   - **Implementation**:
     - Create test YAML files with predictable, small datasets
     - Add test-specific API endpoints that use isolated data
     - Update integration tests to use test endpoints
   - **Tests**: Integration tests that are fast and reliable
   - **Quality**: Tests that don't break when production data changes

---

### Phase 1: Shared Utilities for API (Python)

3. **YAML/Data File Utility Module** ‚úÖ COMPLETE
   - Create a shared utility for loading, saving, and validating YAML/data files.
   - Refactor all API modules to use these utilities for file I/O and validation.
   - **Implementation**: Created `webui/api/utils/yaml_utils.py` with comprehensive functions:
     - `load_yaml_file()` - Load YAML with error handling
     - `save_yaml_file()` - Save with atomic write
     - `validate_yaml_structure()` - Validate data types
     - `validate_required_fields()` - Check required fields
   - **Tests**: 18 comprehensive unit tests covering all functions and edge cases
   - **Refactoring**: Successfully refactored `brush_splits.py` to use new utilities
   - **Integration Tests**: 6 tests verifying the refactored module works correctly
   - **Quality**: All tests passing (24 total), linting clean, committed with clear message

4. **Centralized Error Handling**
   - Implement a decorator/context manager for API error handling.
   - Refactor endpoints to use this for consistent error responses.

5. **Base Validator Class**
   - Create a base validator for product-type validation logic.
   - Refactor product-specific validators to inherit from this.

---

### Phase 2: WebUI DRY Refactoring (React/TypeScript)

6. **Remove Manual Cache-Busting**
   - Ensure all cache-busting is handled by the Axios interceptor.
   - Remove manual timestamp query params from API calls.

7. **Generic DataTable Component**
   - Create a generic, configurable DataTable component.
   - Refactor all table/grid components to use this.

8. **Shared Form Field Components**
   - Create generic CheckboxField, SelectField, and InputField components.
   - Refactor forms to use these shared components.

9. **Generalize Data Transformers**
   - If multiple product types need transformation, create a generic transformer pattern.

---

### Phase 3: Testing and Documentation

10. **Test Utilities for Mocks**
    - Create test utilities for common mocks (API, fetch, months).
    - Refactor tests to use these utilities.

11. **Documentation**
    - Document all shared utilities and DRY patterns.
    - Update onboarding/contribution guides.

---

## üîÅ TDD Prompts for Each Step

### Step 1: Fix WebUI Test Mocking Strategy

```text
Fix the failing webui tests by implementing proper axios mocking instead of fetch mocking.
- Write unit tests that properly mock axios responses for API service functions.
- Separate unit tests (mocked) from integration tests (real API).
- Fix the should_not_split tests to use proper mocks and expect correct data.
- Ensure all webui tests pass (currently 3 failing tests).
```

### Step 2: Establish Test Data Isolation Strategy

```text
Create test-specific API endpoints and data files for isolated testing.
- Create test YAML files with predictable, small datasets.
- Add test-specific API endpoints that use isolated data.
- Update integration tests to use test endpoints instead of production data.
- Ensure tests are fast, reliable, and don't depend on changing production data.
```

### Step 3: YAML/Data File Utility Module

```text
Create a Python module (e.g., `webui/api/utils/yaml_utils.py`) with functions for loading, saving, and validating YAML/data files.  
- Write unit tests for all utility functions (load, save, validate, error cases).
- Refactor one API module (e.g., `brush_splits.py`) to use the new utility.
- Ensure all tests pass and error handling is consistent.
```

### Step 4: Centralized Error Handling

```text
Implement a decorator or context manager for API error handling in Python.  
- Write unit tests for the decorator/context manager (test various error types and responses).
- Refactor one endpoint to use the decorator.
- Ensure error responses are consistent and tests pass.
```

### Step 5: Base Validator Class

```text
Create a base validator class for product-type validation logic in Python.  
- Write unit tests for the base class (test required field validation, error cases).
- Refactor one product-specific validator to inherit from the base.
- Ensure all tests pass and logic is DRY.
```

### Step 6: Remove Manual Cache-Busting

```text
Audit all API calls in the webui for manual cache-busting query params.  
- Write a test that fails if manual `_t=` params are present in API calls.
- Refactor code to rely solely on the Axios interceptor.
- Ensure all tests pass and no manual cache-busting remains.
```

### Step 7: Generic DataTable Component

```text
Create a generic DataTable React component that accepts columns, data, and row renderers as props.  
- Write unit tests for the DataTable (renders columns, rows, handles empty data, etc.).
- Refactor one table component (e.g., `BrushSplitTable`) to use the generic DataTable.
- Ensure all tests pass and UI is unchanged.
```

### Step 8: Shared Form Field Components

```text
Create generic CheckboxField, SelectField, and InputField React components.  
- Write unit tests for each field component (renders, handles input, error states).
- Refactor one form to use the shared components.
- Ensure all tests pass and form behavior is unchanged.
```

### Step 9: Generalize Data Transformers

```text
If multiple product types require data transformation, create a generic transformer pattern in TypeScript.  
- Write unit tests for the generic transformer (handles various product types, error cases).
- Refactor one transformer to use the generic pattern.
- Ensure all tests pass and data is transformed correctly.
```

### Step 10: Test Utilities for Mocks

```text
Create test utility functions for common mocks (API, fetch, months) in the webui.  
- Write unit tests for the utilities.
- Refactor one test file to use the utilities.
- Ensure all tests pass and mocking is consistent.
```

### Step 11: Documentation

```text
Document all shared utilities and DRY patterns in the codebase.  
- Add or update documentation in `docs/` and code comments.
- Update onboarding/contribution guides to reference shared patterns.
- Ensure documentation is clear and up to date.
```

---

## üß™ Testing Requirements (per @sotd-pipeline-core.mdc)

- **Unit Tests**: Required for all new utilities, components, and refactored logic. List specific functions/components to be tested in each step.
- **Integration Tests**: Required for all refactored API endpoints and major UI flows. Specify real data files and workflow scenarios.
- **E2E Tests**: Optional, only for full user workflows (e.g., Playwright for UI, API integration for backend).
- **Test Coverage**: Minimum 90% for new/refactored code. All critical paths and error handling must be tested.
- **Error Handling**: All error scenarios must be tested (file not found, invalid data, API errors, etc.).
- **Performance**: Add performance tests for utilities/components that may impact load time or throughput.
- **Test File Locations**: Mirror source structure (e.g., `tests/api/test_yaml_utils.py`, `src/components/__tests__/DataTable.test.tsx`).
- **Mock Data**: Define and use mock data for all unit tests. Specify requirements in each step.
- **Test Execution**: Use `make format lint typecheck test` before commits. E2E: `npm run test:e2e:background` if needed.

---

## üß† Critical Analysis

- Each step is self-contained and test-first.
- No step produces orphaned or non-integrated code.
- Steps are small enough for safe, incremental progress.
- Prompts are ready for codegen or manual implementation.
- Plan is lean, avoids over-abstraction, and focuses on measurable DRY improvements.

---
description:
globs:
alwaysApply: false
---
